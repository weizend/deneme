function listenForEventsTab() {
    // Referanslara şampiyon verilerini de ekliyoruz.
    const eventRefs = [
        db.ref('gameConfig/monsterBattle'),        // 0
        db.ref('clickCatchLobby'),                 // 1
        db.ref('gameConfig/weeklyClickCatchReset'),// 2
        db.ref('wordGame'),                        // 3
        db.ref('gameConfig/cardCollectionStatus'), // 4
        db.ref('gameStats/wordGameChampion'),      // 5
        db.ref('gameStats/weeklyClickCatchWinner'),// 6
    ];

    const renderEvents = async () => {
        const container = document.getElementById('activityFeedTab-etkinlikler');
        container.innerHTML = '<p class="text-center text-gray-400">Etkinlik durumu kontrol ediliyor...</p>';

        const snapshots = await Promise.all(eventRefs.map(ref => ref.once('value')));
        
        let html = '';
        
        const monsterData = snapshots[0].val();
        const lobbyData = snapshots[1].val();
        const weeklyData = snapshots[2].val();
        const wordGameData = snapshots[3].val();
        const collectionStatus = snapshots[4].val();
        const wordGameChampionData = snapshots[5].val();
        const weeklyWinnerData = snapshots[6].val();

        // 1. Canavar Savaşı
        if (monsterData && monsterData.monsterDetails) {
            if (monsterData.monsterDetails.currentHP > 0) {
                // Etkinlik devam ediyor...
                const sortedLeaderboard = Object.entries(monsterData.damageLeaderboard || {}).sort((a,b) => b[1].totalDamage - a[1].totalDamage);
                const leader = sortedLeaderboard.length > 0 ? sortedLeaderboard[0] : null;
                const leaderText = leader ? `1. sırada <b class="text-white">${leader[0]}</b> (${formatNumber(leader[1].totalDamage)} Hasar)` : '1. sıra için oyuncu bekleniyor.';
                const prize = monsterData.rewards?.onKillLeader;
                const prizeText = prize ? `${formatNumber(prize.value)} ${typeToName[prize.type]}` : 'Belirlenmedi';

                html += `
                    <div class="event-card ongoing">
                        <h5 class="font-bold text-white mb-2">Canavar Savaşı Etkinliği Başladı!</h5>
                        <p class="text-sm text-gray-300"><b class="text-red-400">${monsterData.monsterDetails.name}</b> canavarı arenaya geldi.</p>
                        <p class="text-sm text-gray-300">Liderlik Ödülü: <b class="text-green-400">${prizeText}</b></p>
                        <p class="text-sm text-gray-300 mt-2">${leaderText}</p>
                        <p class="text-xs text-lime-400 font-bold mt-1">Etkinlik devam ediyor</p>
                    </div>`;
            } else {
                // Etkinlik bitti...
                html += `
                    <div class="event-card finished">
                        <h5 class="font-bold text-white mb-2">Canavar Savaşı Etkinliği Bitti!</h5>
                        <p class="text-sm text-gray-400">Şampiyon seçildi ve etkinlik bitti. Yöneticinin etkinliği yeniden başlatması bekleniyor.</p>
                    </div>`;
            }
        }
        
        // 2. Tıkla-Yakala Lobi (Sadece aktifken gösterilir)
        if (lobbyData && (lobbyData.state === 'waiting' || lobbyData.state === 'active')) {
             const stateText = lobbyData.state === 'waiting' ? 'Katılımcı Bekleniyor' : 'Etkinlik devam ediyor';
             const katilimText = lobbyData.entryTickets > 0 ? `${lobbyData.entryTickets} Bilet` : `${lobbyData.entryFee} Puan`;
             html += `
                <div class="event-card ongoing">
                    <h5 class="font-bold text-white mb-2">Tıkla-Yakala Lobi Etkinliği Başladı!</h5>
                    <p class="text-sm text-gray-300">Katılım: <b class="text-yellow-400">${katilimText}</b> | Ödül: <b class="text-green-400">${formatNumber(lobbyData.prize)} Puan</b></p>
                    <p class="text-xs text-lime-400 font-bold mt-1">${stateText}</p>
                </div>`;
        }
        
        // 3. Tıkla-Yakala Haftalık
        if (weeklyData && weeklyData.endDate) {
            const prize = weeklyData.prize;
            const prizeText = prize.type === 'special' ? prize.name : `${formatNumber(prize.amount)} ${typeToName[prize.type]}`;
            const scoresSnap = await db.ref('clickCatchWeeklyScores').orderByValue().limitToLast(1).once('value');
            let leaderText = '1. sıra için oyuncu bekleniyor.';
            if (scoresSnap.exists()) {
                const leaderUsername = Object.keys(scoresSnap.val())[0];
                const leaderScore = scoresSnap.val()[leaderUsername];
                leaderText = `1. sırada <b class="text-white">${leaderUsername}</b> (${formatNumber(leaderScore)} Skor)`;
            }

            html += `
                <div class="event-card ongoing">
                    <h5 class="font-bold text-white mb-2">Tıkla-Yakala Haftalık Etkinliği</h5>
                    <p class="text-sm text-gray-300">Haftanın Şampiyonu Ödülü: <b class="text-green-400">${prizeText}</b></p>
                    <p class="text-sm text-gray-300 mt-2">${leaderText}</p>
                    <p class="text-xs text-lime-400 font-bold mt-1">Etkinlik devam ediyor</p>
                </div>`;
        } else if (weeklyWinnerData) {
             html += `
                <div class="event-card finished">
                    <h5 class="font-bold text-white mb-2">Tıkla-Yakala Haftalık Etkinliği Bitti!</h5>
                    <p class="text-sm text-gray-400">Şampiyon seçildi ve etkinlik bitti. Yöneticinin etkinliği yeniden başlatması bekleniyor.</p>
                </div>`;
        }

        // 4. Kelime Oyunu
        if (wordGameData && wordGameData.questions) {
            if (wordGameChampionData) {
                 html += `
                <div class="event-card finished">
                    <h5 class="font-bold text-white mb-2">Kelime Oyunu Etkinliği Bitti!</h5>
                    <p class="text-sm text-gray-400">Şampiyon seçildi ve etkinlik bitti. Yöneticinin etkinliği yeniden başlatması bekleniyor.</p>
                </div>`;
            } else {
                const sortedLeaderboard = Object.entries(wordGameData.leaderboard || {}).sort((a,b) => b[1].score - a[1].score);
                const leader = sortedLeaderboard.length > 0 ? sortedLeaderboard[0] : null;
                const leaderText = leader ? `1. sırada <b class="text-white">${leader[0]}</b> (${leader[1].score} Harf)` : '1. sıra için oyuncu bekleniyor.';
                const prize = wordGameData.settings?.championPrize;
                const prizeText = prize ? formatRewardText(prize.type, prize.amount || prize.value, prize.uses) : 'Belirlenmedi';
                 html += `
                    <div class="event-card ongoing">
                        <h5 class="font-bold text-white mb-2">Kelime Oyunu Etkinliği Başladı!</h5>
                        <p class="text-sm text-gray-300">Şampiyon Ödülü: <b class="text-green-400">${prizeText}</b></p>
                        <p class="text-sm text-gray-300 mt-2">${leaderText}</p>
                        <p class="text-xs text-lime-400 font-bold mt-1">Etkinlik devam ediyor</p>
                    </div>`;
            }
        }

        // 5. Kart Koleksiyonu
        if (collectionStatus === 'active') {
             const prizeSnap = await db.ref('gameConfig/collectionGrandPrize').once('value');
             const prize = prizeSnap.val();
             const prizeText = prize && prize.description ? prize.description : "Büyük Ödül";
             
             const finishersSnap = await db.ref('gameStats/collectionFinishers').once('value');
             let leaderText = 'Henüz kimse albümü tamamlamadı.';
             if (finishersSnap.exists()) {
                 const firstFinisher = Object.values(finishersSnap.val()).sort((a,b) => a.timestamp - b.timestamp)[0];
                 leaderText = `1. sırada <b class="text-white">${firstFinisher.username}</b> (Tamamladı)`;
             }

             html += `
                <div class="event-card ongoing">
                    <h5 class="font-bold text-white mb-2">Kart Koleksiyonu Etkinliği Başladı!</h5>
                    <p class="text-sm text-gray-300">Büyük Ödül: <b class="text-green-400">${prizeText}</b></p>
                    <p class="text-sm text-gray-300 mt-2">${leaderText}</p>
                    <p class="text-xs text-lime-400 font-bold mt-1">Sezon Devam Ediyor</p>
                </div>`;
        }

        container.innerHTML = html || '<p class="text-center text-gray-400 p-4">Şu anda aktif bir etkinlik bulunmuyor.</p>';
    };
    
    // Herhangi bir etkinlik verisi değiştiğinde sekme içeriğini yeniden oluşturulsun diye dinleyicileri ata
    eventRefs.forEach(ref => ref.on('value', renderEvents));
}

// MEVCUT attackMonster FONKSİYONUNU SİLİP BUNU YAPIŞTIR
async function attackMonster() {
    if (isAdmin) {
        displayMessage("Adminler saldıramaz.");
        return;
    }
    
    if (attackCooldown) return;

    const attackBtn = document.getElementById('attackMonsterBtn');
    
    try {
        const userRef = db.ref(`users/${currentUser}`);
        const battleRef = db.ref('gameConfig/monsterBattle');

        const [userSnap, battleSnap] = await Promise.all([userRef.once('value'), battleRef.once('value')]);
        
        const userData = userSnap.val();
        const battleData = battleSnap.val();

        if (!userData || !battleData || !battleData.monsterDetails || battleData.monsterDetails.currentHP <= 0) {
            throw new Error("Savaş durumu geçersiz veya canavar zaten ölü.");
        }
        
        const playerBattleData = battleData.damageLeaderboard?.[currentUser];

        if (!playerBattleData) {
            if (!userData.selectedAvatar || !userData.selectedAvatar.url) {
                displayMessage("Savaşa katılmak için önce envanterden bir avatar seçmelisin!");
                return;
            }
            const confirmed = await customConfirm(
                `Canavara ilk saldırını yapıyorsun! Bu saldırıdan sonra, şu an seçili olan avatarın bu canavar ölene kadar kilitlenecek ve değiştirilemeyecek. Devam etmek istiyor musun?`
            );
            if (!confirmed) return; 
        }

        if (playerBattleData && playerBattleData.currentHP <= 0) {
            throw new Error("Savaşmak için canın kalmadı! Dirilme Taşı kullanmalısın.");
        }
        
        attackCooldown = true;
        attackBtn.disabled = true;

        const playerAvatarUrl = playerBattleData?.lockedAvatarUrl || userData.selectedAvatar?.url || defaultAvatarUrl;
        const sanitizedPlayerAvatarId = sanitizeFirebaseKey(playerAvatarUrl);
        const playerBaseStats = avatarBaseStats[sanitizedPlayerAvatarId] || {};
        const globalBuffs = userData.globalPotionBuffs || {};

        const playerStats = {
            hp: (playerBaseStats.hp || 1000) + (globalBuffs.hp || 0),
            minDamage: (playerBaseStats.minDamage || 50) + (globalBuffs.damage || 0),
            maxDamage: (playerBaseStats.maxDamage || 100) + (globalBuffs.damage || 0),
            defense: (playerBaseStats.defense || 10) + (globalBuffs.defense || 0),
            critChance: (playerBaseStats.critChance || 5) + (globalBuffs.critChance || 0),
            critDamage: (playerBaseStats.critDamage || 10) + (globalBuffs.critDamage || 0),
            dodgeChance: (playerBaseStats.dodgeChance || 5) + (globalBuffs.dodgeChance || 0),
            pierceChance: (playerBaseStats.pierceChance || 5) + (globalBuffs.pierceChance || 0),
        };
        const monsterStats = battleData.monsterDetails;
        
        const monsterDefenseReduction = Math.min((monsterStats.defense || 0) / 100, 0.8);
        const playerDefenseReduction = Math.min((playerStats.defense || 0) / 100, 0.8);

        let finalDamageToMonster = 0;
        let playerAttackType = 'normal';
        const playerPierced = (Math.random() * 100) < playerStats.pierceChance;
        const didMonsterDodge = !playerPierced && (Math.random() * 100) < (monsterStats.dodgeChance || 0);
        let playerAttackDetails = '';

        if (didMonsterDodge) {
            playerAttackDetails = `Canavar saldırından <b class="text-cyan-400">sıyrıldı!</b>`;
        } else {
            const playerCritted = (Math.random() * 100) < playerStats.critChance;
            let totalDamage;

            if (playerCritted) {
                totalDamage = playerStats.maxDamage + Math.floor(playerStats.maxDamage * (playerStats.critDamage / 100));
            } else {
                totalDamage = Math.floor(Math.random() * (playerStats.maxDamage - playerStats.minDamage + 1)) + playerStats.minDamage;
            }
            
            if (playerPierced) {
                finalDamageToMonster = playerStats.maxDamage;
                playerAttackType = 'pierce';
                playerAttackDetails = `📌 <b class="text-purple-400">Delici Vuruş</b> ile canavara <b class="text-white">${finalDamageToMonster} hasar</b> verdin.`;
            } else {
                finalDamageToMonster = Math.max(1, Math.floor(totalDamage * (1 - monsterDefenseReduction)));
                if(playerCritted) {
                    playerAttackType = 'crit';
                    playerAttackDetails = `💥 <b class="text-amber-400">Kritik Vuruş</b> ile canavara <b class="text-white">${finalDamageToMonster} hasar</b> verdin.`;
                } else {
                    playerAttackDetails = `Canavara <b class="text-white">${finalDamageToMonster} hasar</b> verdin.`;
                }
            }
        }

        let finalDamageToPlayer = 0;
        let monsterAttackType = 'normal';
        const monsterPierced = (Math.random() * 100) < (monsterStats.pierceChance || 5);
        const didPlayerDodge = !monsterPierced && (Math.random() * 100) < playerStats.dodgeChance;
        let monsterAttackDetails = '';

        if (didPlayerDodge) {
            monsterAttackDetails = `Canavarın saldırısından <b class="text-cyan-400">sıyrıldın!</b>`;
        } else {
            const monsterCritted = (Math.random() * 100) < (monsterStats.critChance || 5);
            let totalDamage;

            if (monsterCritted) {
                totalDamage = monsterStats.maxDamage + Math.floor(monsterStats.maxDamage * ((monsterStats.critDamage || 10) / 100));
            } else {
                totalDamage = Math.floor(Math.random() * (monsterStats.maxDamage - monsterStats.minDamage + 1)) + monsterStats.minDamage;
            }

            if (monsterPierced) {
                finalDamageToPlayer = monsterStats.maxDamage;
                monsterAttackType = 'pierce';
                monsterAttackDetails = `📌 Canavar <b class="text-purple-400">delici vuruşla</b> sana <b class="text-red-400">${finalDamageToPlayer} hasar</b> verdi.`;
            } else {
                finalDamageToPlayer = Math.max(1, Math.floor(totalDamage * (1 - playerDefenseReduction)));
                if(monsterCritted) {
                    monsterAttackType = 'crit';
                    monsterAttackDetails = `💥 Canavar <b class="text-amber-400">kritik vuruşla</b> sana <b class="text-red-400">${finalDamageToPlayer} hasar</b> verdi.`;
                } else {
                    monsterAttackDetails = `Canavar sana <b class="text-red-400">${finalDamageToPlayer} hasar</b> verdi.`;
                }
            }
        }
        
        let randomReward = null;
        const damageTiers = (battleData.damageTiers || []).sort((a, b) => b.minDamage - a.minDamage);
        for (const tier of damageTiers) {
            if (finalDamageToMonster >= tier.minDamage) {
                const totalChance = tier.rewards.reduce((sum, r) => sum + r.chance, 0);
                let randomRoll = Math.random() * totalChance;
                for (const reward of tier.rewards) {
                    randomRoll -= reward.chance;
                    if (randomRoll <= 0) { randomReward = reward; break; }
                }
                break; 
            }
        }
        
        let finalPlayerHP = 0;
        let finalMonsterHP = 0;
        let finalTotalPlayerDamage = 0;
        let playerDiedInAttack = false;

        await battleRef.transaction(currentBattleData => {
            if (!currentBattleData || !currentBattleData.monsterDetails || currentBattleData.monsterDetails.currentHP <= 0) return;
            
            finalMonsterHP = Math.max(0, currentBattleData.monsterDetails.currentHP - finalDamageToMonster);
            currentBattleData.monsterDetails.currentHP = finalMonsterHP;

            if (!currentBattleData.damageLeaderboard) currentBattleData.damageLeaderboard = {};
            if (!currentBattleData.damageLeaderboard[currentUser]) {
                currentBattleData.damageLeaderboard[currentUser] = { totalDamage: 0, currentHP: playerStats.hp, lockedAvatarUrl: playerAvatarUrl };
            }

            const currentPlayerBattleData = currentBattleData.damageLeaderboard[currentUser];
            currentPlayerBattleData.totalDamage += finalDamageToMonster;
            finalTotalPlayerDamage = currentPlayerBattleData.totalDamage;
            
            currentPlayerBattleData.currentHP = Math.max(0, currentPlayerBattleData.currentHP - finalDamageToPlayer);
            finalPlayerHP = currentPlayerBattleData.currentHP;
            
            if (finalPlayerHP <= 0) playerDiedInAttack = true;
            return currentBattleData;
        });
        
        const updates = {};
        let rewardMessage = '';
        let rewardLogText = '';
        if (randomReward) {
            const { type, value } = randomReward;
            const prizeName = typeToName[type] || 'Ödül';
            const isPercent = ['defense_potion', 'crit_potion', 'crit_damage_potion', 'dodge_potion', 'pierce_potion', 'health_regen_potion'].includes(type);
            // ★★★ İSTEĞE GÖRE GÜNCELLENEN MESAJ ALANI ★★★
            const valuePrefix = isPercent ? `%` : `+`;
            
            rewardMessage = `<hr class="border-gray-600 my-2">🎉 <b>Ödül:</b> <b class="text-green-400">${valuePrefix}${value} ${prizeName}</b> kazandın!`;
            rewardLogText = `${valuePrefix}${value} ${prizeName}`;
            
            if (type === 'health_regen_potion') {
                const currentPotions = userData.inventory?.health_regen_potion?.[value] || 0;
                updates[`/users/${currentUser}/inventory/health_regen_potion/${value}`] = currentPotions + 1;
            } else {
                const dbKeyMap = { points: 'balance', boxRights: 'kutuHakki', wheelTicket: 'carkBileti', clickCatchTicket: 'clickCatchTickets', iflasShield: 'iflasShieldUses', wildcard: 'wildcards', revival_stone: 'inventory/revival_stone' };
                const statKeyMap = { health_potion: 'hp', damage_potion: 'damage', defense_potion: 'defense', crit_potion: 'critChance', crit_damage_potion: 'critDamage', dodge_potion: 'dodgeChance', pierce_potion: 'pierceChance' };
                if (type === 'points') {
                    updates[`/users/${currentUser}/balance`] = (userData.balance || 0) + value;
                    updates[`/users/${currentUser}/kariyerPuani`] = (userData.kariyerPuani || 0) + value;
                } else if (type.startsWith('card_pack')) {
                     startCardPackOpening(value, 'Canavar Savaşı', 1, type);
                } else if (dbKeyMap[type]) {
                    const path = `/users/${currentUser}/${dbKeyMap[type]}`;
                    const pathParts = dbKeyMap[type].split('/');
                    const currentValue = pathParts.length > 1 ? (userData.inventory?.[pathParts[1]] || 0) : (userData[pathParts[0]] || 0);
                    updates[path] = currentValue + value;
                } else if (statKeyMap[type]) {
                    const statKey = statKeyMap[type];
                    const capCheck = checkPotionCap(userData, type, value);
                    if (capCheck.canAdd && capCheck.amount > 0) {
                        const path = `/users/${currentUser}/globalPotionBuffs/${statKey}`;
                        const currentValue = userData.globalPotionBuffs?.[statKey] || 0;
                        updates[path] = currentValue + capCheck.amount;
                        if(capCheck.isCapped) rewardMessage += ` (Limite ulaşıldı!)`;
                    } else {
                        rewardMessage += ` (Limitte olduğu için kazanılamadı!)`;
                    }
                }
            }
        }
        if (Object.keys(updates).length > 0) await db.ref().update(updates);
        
        logActivity('monsterAttack', currentUser, {
            monsterName: monsterStats.name,
            damageDealt: finalDamageToMonster,
            damageTaken: finalDamageToPlayer,
            playerAttackType: playerAttackType,
            monsterAttackType: monsterAttackType,
            didPlayerDodge: didPlayerDodge,
            didMonsterDodge: didMonsterDodge,
            playerRemainingHP: finalPlayerHP,
            playerMaxHP: playerStats.hp,
            monsterRemainingHP: finalMonsterHP,
            monsterMaxHP: monsterStats.maxHP,
            playerTotalDamage: finalTotalPlayerDamage,
            rewardWon: rewardLogText,
            playerDied: playerDiedInAttack
        });
        
        let attackInfoMessage = `
            <div class="text-left space-y-2">
                <p><b>Senin Saldırın:</b> ${playerAttackDetails}</p>
                <p><b>Canavarın Saldırısı:</b> ${monsterAttackDetails}</p>
                ${rewardMessage}
            </div>
        `;

        showFloatingText(`-${finalDamageToMonster}`, document.getElementById('monsterImage').getBoundingClientRect().left + 100, document.getElementById('monsterImage').getBoundingClientRect().top + 100);
        displayMessage(attackInfoMessage);
        
        const finalBattleSnap = await battleRef.once('value');
        const finalBattleData = finalBattleSnap.val();

        if (finalBattleData && finalBattleData.monsterDetails.currentHP <= 0) {
            const sortedLeaderboard = Object.entries(finalBattleData.damageLeaderboard || {}).sort((a,b) => b[1].totalDamage - a[1].totalDamage);
            const winner = sortedLeaderboard.length > 0 ? sortedLeaderboard[0][0] : null;
            const winnerData = winner ? finalBattleData.damageLeaderboard[winner] : null;
            const prize = finalBattleData.rewards?.onKillLeader;

            if (winner && prize && winnerData) {
                await db.ref('gameStats/lastMonsterChampion').set({
                    username: winner,
                    totalDamage: winnerData.totalDamage,
                    lockedAvatarUrl: winnerData.lockedAvatarUrl
                });

                const prizeName = typeToName[prize.type] || prize.type;
                const prizeText = `${prize.value} ${prizeName}`;
                
                logActivity('monsterDefeated', 'WeizendTv', { 
                    monsterName: finalBattleData.monsterDetails.name, 
                    winner: winner, 
                    prize: prizeText,
                    totalDamage: winnerData.totalDamage
                });
                // attackMonster fonksiyonundaki logActivity('monsterDefeated'...) satırının altına ekle
logActivity('event', 'WeizendTv', { eventType: 'monster', status: 'finished', winner: winner }, 'etkinlikler');
                
                const winnerRef = db.ref(`users/${winner}`);
                await winnerRef.transaction(winnerDataFromDB => {
                    if (winnerDataFromDB) {
                         const { type, value } = prize;
                         if(type === 'health_regen_potion'){
                            if(!winnerDataFromDB.inventory) winnerDataFromDB.inventory = {};
                            if(!winnerDataFromDB.inventory.health_regen_potion) winnerDataFromDB.inventory.health_regen_potion = {};
                            const currentPotions = winnerDataFromDB.inventory.health_regen_potion[value] || 0;
                            winnerDataFromDB.inventory.health_regen_potion[value] = currentPotions + 1;
                         } else {
                             const dbKeyMap = { points: 'balance', boxRights: 'kutuHakki', wheelTicket: 'carkBileti', clickCatchTicket: 'clickCatchTickets', iflasShield: 'iflasShieldUses', wildcard: 'wildcards', revival_stone: 'inventory/revival_stone' };
                             const statKeyMap = { health_potion: 'hp', damage_potion: 'damage', defense_potion: 'defense', crit_potion: 'critChance', crit_damage_potion: 'critDamage', dodge_potion: 'dodgeChance', pierce_potion: 'pierceChance' };
                             
                             if (type === 'points') {
                                winnerDataFromDB.balance = (winnerDataFromDB.balance || 0) + value;
                                winnerDataFromDB.kariyerPuani = (winnerDataFromDB.kariyerPuani || 0) + value;
                             } else if (type.startsWith('card_pack')) {
                                 const packKey = db.ref().push().key;
                                 if (!winnerDataFromDB.pendingActions) winnerDataFromDB.pendingActions = {};
                                 if (!winnerDataFromDB.pendingActions.cardPacks) winnerDataFromDB.pendingActions.cardPacks = {};
                                 winnerDataFromDB.pendingActions.cardPacks[packKey] = { type: type, count: value };
                             } else if (dbKeyMap[type]) {
                                 const pathParts = dbKeyMap[type].split('/');
                                 if (pathParts.length > 1) {
                                     if (!winnerDataFromDB[pathParts[0]]) winnerDataFromDB[pathParts[0]] = {};
                                     winnerDataFromDB[pathParts[0]][pathParts[1]] = (winnerDataFromDB[pathParts[0]][pathParts[1]] || 0) + value;
                                 } else {
                                     winnerDataFromDB[dbKeyMap[type]] = (winnerDataFromDB[dbKeyMap[type]] || 0) + value;
                                 }
                             } else if (statKeyMap[type]) {
                                const statKey = statKeyMap[type];
                                const capCheck = checkPotionCap(winnerDataFromDB, type, value);
                                if (capCheck.canAdd && capCheck.amount > 0) {
                                    if (!winnerDataFromDB.globalPotionBuffs) winnerDataFromDB.globalPotionBuffs = {};
                                    winnerDataFromDB.globalPotionBuffs[statKey] = (winnerDataFromDB.globalPotionBuffs[statKey] || 0) + capCheck.amount;
                                }
                             }
                         }

                         if (!winnerDataFromDB.monsterChampionships) {
                             winnerDataFromDB.monsterChampionships = [];
                         }
                         winnerDataFromDB.monsterChampionships.push({
                             timestamp: firebase.database.ServerValue.TIMESTAMP,
                             monsterName: finalBattleData.monsterDetails.name,
                             damage: winnerData.totalDamage
                         });
                    }
                    return winnerDataFromDB;
                });
            }
        }

    } catch (error) {
        displayMessage(error.message);
    } finally {
        let count = 3;
        const interval = setInterval(() => {
            attackBtn.textContent = `BEKLE (${count--})`;
            if (count < 0) {
                clearInterval(interval);
                attackCooldown = false;
                attackBtn.disabled = false;
                attackBtn.textContent = 'SALDIR!';
            }
        }, 1000);
    }
}
      
// YENİ: Canavar Savaşı Bilgi Modal'ını açar ve kapatır
function openMonsterBattleInfoModal() {
    document.getElementById('monsterBattleInfoModal').style.display = 'flex';
}
function closeMonsterBattleInfoModal() {
    document.getElementById('monsterBattleInfoModal').style.display = 'none';
}

// useRevivalStone fonksiyonunu bununla değiştir
async function useRevivalStone() {
    if (isAdmin) return;

    const reviveBtn = document.getElementById('reviveBtn');
    reviveBtn.disabled = true;

    try {
        const userRef = db.ref(`users/${currentUser}`);
        const battleRef = db.ref('gameConfig/monsterBattle');

        const [userSnap, battleSnap] = await Promise.all([userRef.once('value'), battleRef.once('value')]);
        
        const userData = userSnap.val();
        const battleData = battleSnap.val();
        
        const playerBattleData = battleData?.damageLeaderboard?.[currentUser];

        if (!playerBattleData || playerBattleData.currentHP > 0) {
            throw new Error("Canın zaten dolu veya savaşta değilsin.");
        }

        const revivalStones = userData.inventory?.revival_stone || 0;
        if (revivalStones < 1) {
            // GÜNCELLEME BURADA
            displayMessageWithRedirect("Dirilmek için Dirilme Taşın yok!", "Mağazaya Git", () => {
                storeFilter = { type: 'revival_stone' };
                showSection('store');
            });
            return; 
        }

        const stoneRef = userRef.child('inventory/revival_stone');
        const { committed } = await stoneRef.transaction(currentStones => {
            if ((currentStones || 0) > 0) {
                return currentStones - 1;
            }
            return;
        });
        
        if (!committed) {
            throw new Error("Dirilme taşı kullanılamadı. Envanterin başka bir işlem tarafından güncellenmiş olabilir.");
        }
        
        const playerAvatarUrl = playerBattleData.lockedAvatarUrl || userData.selectedAvatar?.url || defaultAvatarUrl;
        const sanitizedPlayerAvatarId = sanitizeFirebaseKey(playerAvatarUrl);
        
        const globalBuffs = userData.globalPotionBuffs || {};
        const baseStats = avatarBaseStats[sanitizedPlayerAvatarId] || {};
        const playerMaxHP = (baseStats.hp || 1000) + (globalBuffs.hp || 0);

        await battleRef.child(`damageLeaderboard/${currentUser}/currentHP`).set(playerMaxHP);

        displayMessage("Dirilme Taşı kullanıldı ve canın tamamen yenilendi. Tekrar savaşa hazırsın!");

    } catch (error) {
        displayMessage(error.message);
    } finally {
        reviveBtn.disabled = false;
    }
}

/**
 * Adminin mevcut canavarı oyundan kaldırmasını sağlar.
 */
async function deleteCurrentMonster() {
    if (!isAdmin) return;
    const confirmed = await customConfirm("Mevcut canavarı ve tüm savaş ilerlemesini kalıcı olarak silmek istediğinizden emin misiniz?");
    if (confirmed) {
        await db.ref('gameConfig/monsterBattle').remove();
        displayMessage("Canavar başarıyla kaldırıldı.");
    }
}

function openMonsterInfoModal() {
    const monster = monsterBattleData.monsterDetails;
    if (!monster) return;

    document.getElementById('modalMonsterName').textContent = monster.name;
    const imgEl = document.getElementById('modalMonsterImage');
    if (imgEl && monster.imageUrl) {
        imgEl.src = monster.imageUrl;
        imgEl.style.display = 'block';
    } else if (imgEl) {
        imgEl.style.display = 'none';
    }
    
    const statsEl = document.getElementById('modalMonsterStats');
    statsEl.innerHTML = `
        <p>❤️ Can: <b class="text-white">${formatNumber(monster.maxHP)}</b></p>
        <p>⚔️ Hasar: <b class="text-white">${formatNumber(monster.minDamage)} - ${formatNumber(monster.maxDamage)}</b></p>
        <p>🎯 Kritik Hasar: <b class="text-white">+%${(monster.critDamage || 10).toFixed(1)}</b></p>
        <p>🛡️ Savunma Şansı: <b class="text-white">%${(monster.defense || 0).toFixed(1)}</b></p>
        <p>💨 Sıyrılma Şansı: <b class="text-white">%${(monster.dodgeChance || 5).toFixed(1)}</b></p>
        <p>📌 Delici Vuruş Şansı: <b class="text-white">%${(monster.pierceChance || 5).toFixed(1)}</b></p>
        <p>💥 Kritik Vuruş Şansı: <b class="text-white">%${(monster.critChance || 5).toFixed(1)}</b></p>
    `;

    const killReward = monsterBattleData.rewards?.onKillLeader;
    const killRewardEl = document.getElementById('modalKillReward');
    if (killReward) {
        const prizeText = formatRewardText(killReward.type, killReward.value);
        killRewardEl.innerHTML = `Canavar yok edildiği zaman hasar tablosunda 1. sırada olan oyuncu <b class="text-green-400">${prizeText}</b> kazanır.`;
    } else {
        killRewardEl.textContent = 'Liderlik ödülü belirlenmemiş.';
    }

    const tiers = monsterBattleData.damageTiers || [];
    const tiersEl = document.getElementById('modalDamageTiers');
    if (tiers.length > 0) {
        tiersEl.innerHTML = '';
        tiers.sort((a,b) => a.minDamage - b.minDamage).forEach(tier => {
            const rewardTexts = tier.rewards.map(r => {
                const formattedText = formatRewardText(r.type, r.value);
                return `${formattedText} (%${r.chance})`;
            }).join(', ');
            
            tiersEl.innerHTML += `<div><b class="text-white">${formatNumber(tier.minDamage)}+ Hasar</b> vuranlar şu ödüllerden birini kazanma şansı yakalar: <span class="text-cyan-300">${rewardTexts}</span></div>`;
        });
    } else {
        tiersEl.textContent = 'Bu canavar için özel hasar eşiği ödülü ayarlanmamış.';
    }

    document.getElementById('monsterInfoModal').style.display = 'flex';
}
      
/**
 * Canavar bilgi penceresini kapatır.
 */
function closeMonsterInfoModal() {
    document.getElementById('monsterInfoModal').style.display = 'none';
}

 /**
 * Firebase anahtarlarında kullanılamayacak yasaklı karakterleri temizler.
 * @param {string} key - Temizlenecek olan metin.
 * @returns {string} Temizlenmiş ve Firebase için güvenli metin.
 */
function sanitizeFirebaseKey(key) {
    if (!key) return '';
    // Firebase'in yasakladığı karakterleri (. # $ [ ] /) bulur ve kaldırır.
    // DEĞİŞİKLİK: ':' ve '/' karakterlerini de '_' ile değiştirerek URL'leri daha güvenli hale getiriyoruz.
    return key.replace(/[.#$[\]/]/g, '').replace(/:/g, '_');
}

function handleWeeklyPrizeTypeChange() {
    const prizeType = document.getElementById('weeklyPrizeType').value;
    const amountInput = document.getElementById('weeklyPrizeAmount');
    const usesInput = document.getElementById('weeklyPrizeMultiplierUses');
    const specialNameInput = document.getElementById('weeklyPrizeSpecialName');

    // Önce tüm özel alanları varsayılan durumuna getir
    amountInput.classList.remove('hidden', 'col-span-2');
    usesInput.classList.add('hidden');
    specialNameInput.classList.add('hidden');

    if (prizeType === 'tempMultiplier') {
        amountInput.placeholder = 'Çarpan Değeri (örn: 2)';
        usesInput.classList.remove('hidden');
    } else if (prizeType === 'special') {
        // Özel ürün seçilirse miktar ve kullanım alanlarını gizle, isim alanını göster
        amountInput.classList.add('hidden');
        usesInput.classList.add('hidden');
        specialNameInput.classList.remove('hidden');
    } else {
        amountInput.placeholder = 'Miktar';
    }
}

      // BU YEPYENİ FONKSİYONU SCRIPT BLOĞUNUZUN UYGUN BİR YERİNE EKLEYİN

function customAlert(message) {
    return new Promise(resolve => {
        const alertBox = document.createElement('div');
        // Z-index'i yüksek tutarak diğer modalların üzerinde görünmesini sağlıyoruz.
        alertBox.className = 'fixed inset-0 bg-black bg-opacity-80 flex justify-center items-center z-[99999]';
        alertBox.innerHTML = `
          <div class="bg-gray-800 p-8 rounded-xl shadow-2xl border border-blue-500 w-11/12 max-w-md text-center relative">
            <p class="text-lg text-gray-300 mb-6">${message}</p>
            <button id="alertOkBtn" class="w-full py-3 bg-blue-700 hover:bg-blue-600 text-white font-bold rounded-lg">Tamam</button>
          </div>
        `;
        document.body.appendChild(alertBox);
        
        document.getElementById('alertOkBtn').onclick = (event) => { 
            event.preventDefault(); 
            alertBox.remove(); 
            resolve(true); // "Tamam" butonuna basıldığında Promise'i çözerek beklemenin bitmesini sağlıyoruz.
        };
    });
}

async function convertWildcard() {
    if (isAdmin) return;

    const confirmed = await customConfirm("1 adet Joker Kart'ı 10 Kutu Hakkı'na dönüştürmek istediğinize emin misiniz? Bu işlem geri alınamaz!");
    if (!confirmed) return;

    const userRef = db.ref(`users/${currentUser}`);

    try {
        const { committed, snapshot } = await userRef.transaction(userData => {
            if (userData && (userData.wildcards || 0) > 0) {
                userData.wildcards--;
                userData.kutuHakki = (userData.kutuHakki || 0) + 10;
                return userData;
            }
            return; 
        });

        if (committed) {
            displayMessage("Başarılı! 1 Joker Kart, 10 Kutu Hakkı'na dönüştürüldü.");
            logActivity('wildcardConvertedToBoxRights', currentUser, {
                boxRights: 10,
                newBoxRights: snapshot.val().kutuHakki
            });
            if (currentActiveSection === 'cardCollection') {
                loadCollectionAlbum();
            }
        } else {
            throw new Error("Dönüştürme işlemi başarısız oldu. Yeterli Joker Kartınız olmayabilir.");
        }
    } catch (error) {
        displayMessage(error.message);
    }
}

      async function resetUser(username) {
    if (!isAdmin || !username) return;

    const confirmed = await customConfirm(
        `<b>${username}</b> adlı kullanıcıyı sıfırlamak istediğinize emin misiniz? Bu işlem, kullanıcının Avatarları, Kasa Puanları ve Kalıcı İksir Bonusları DIŞINDAKİ tüm verilerini (puanlar, envanter, istatistikler, sıralamalar, kartlar vb.) kalıcı olarak silecektir!`
    );

    if (!confirmed) return;

    try {
        const userRef = db.ref(`users/${username}`);
        const userSnap = await userRef.once('value');
        if (!userSnap.exists()) {
            throw new Error("Kullanıcı bulunamadı.");
        }
        const userData = userSnap.val();

        // KORUNACAK VERİLERİ YEDEKLE
        const preservedData = {
            kasaPuani: userData.kasaPuani || 0,
            avatars: userData.avatars || null,
            globalPotionBuffs: userData.globalPotionBuffs || null,
            password: userData.password,
            pin: userData.pin,
            approved: userData.approved,
            registeredAt: userData.registeredAt || new Date().toLocaleString()
        };

        // KULLANICIYI SİLİP KORUNAN VERİLERLE YENİDEN OLUŞTUR
        const updates = {};
        updates[`/users/${username}`] = preservedData;
        // GÜNCELLENEN KISIM: İlgili tüm liderlik tablolarından kullanıcıyı temizle
        updates[`/clickCatchWeeklyScores/${username}`] = null;
        updates[`/gameConfig/monsterBattle/damageLeaderboard/${username}`] = null;
        
        await db.ref().update(updates);
        
        displayMessage(`${username} başarıyla sıfırlandı. Kasa Puanı, avatarları ve iksir bonusları korundu.`);
        closeUserManagementModal();
        
    } catch (error) {
        console.error("Kullanıcı sıfırlanırken hata oluştu:", error);
        displayMessage("Kullanıcı sıfırlanırken bir hata meydana geldi: " + error.message);
    }
}

// BU YEPYENİ FONKSİYONU SCRIPT BLOĞUNUZA EKLEYİN

async function resetUserPotionBonuses(username) {
    if (!isAdmin || !username) return;

    const confirmed = await customConfirm(
        `<b>${username}</b> adlı kullanıcının mağazadan aldığı <b>tüm kalıcı iksir bonuslarını</b> sıfırlamak istediğinize emin misiniz? Bu işlem geri alınamaz!`
    );

    if (!confirmed) return;

    try {
        const userRef = db.ref(`users/${username}`);
        
        // Kullanıcının globalPotionBuffs anahtarını silerek tüm bonusları sıfırla
        await userRef.child('globalPotionBuffs').remove();
        
        displayMessage(`${username} adlı kullanıcının tüm kalıcı iksir bonusları başarıyla sıfırlandı.`);
        
        // Arayüzü anında güncellemek için yönetim modalını yeniden aç
        openUserManagementModal(event, username);
        
    } catch (error) {
        console.error("İksir bonusları sıfırlanırken hata oluştu:", error);
        displayMessage("Bonuslar sıfırlanırken bir hata meydana geldi: " + error.message);
    }
}

// BU YEPYENİ FONKSİYONU SCRIPT BLOĞUNUZA EKLEYİN

/**
 * Adminin, tüm kullanıcıların kalıcı iksir bonuslarını tek seferde sıfırlamasını sağlar.
 */
async function resetAllPotionBonuses() {
    if (!isAdmin) return;

    // Bu, çok güçlü bir işlem olduğu için net bir onay mesajı gösteriyoruz.
    const confirmed = await customConfirm(
        "TÜM kullanıcıların sahip olduğu KALICI iksir bonuslarını sıfırlamak istediğinize emin misiniz? Bu işlem geri alınamaz!"
    );

    if (!confirmed) return;

    try {
        const usersRef = db.ref('users');
        const usersSnap = await usersRef.once('value');
        const usersData = usersSnap.val();

        // Tek seferde yapılacak tüm güncellemeleri bu objede toplayacağız.
        const updates = {};
        
        if (usersData) {
            for (const username in usersData) {
                // Sadece iksir bonusu olan kullanıcılar için silme işlemi hazırla
                if (usersData[username] && usersData[username].globalPotionBuffs) {
                    // globalPotionBuffs anahtarını null olarak ayarlamak, onu veritabanından siler.
                    updates[`/users/${username}/globalPotionBuffs`] = null;
                }
            }
        }

        // Eğer güncellenecek bir şey varsa (yani en az bir kullanıcının bonusu varsa)
        if (Object.keys(updates).length > 0) {
            await db.ref().update(updates);
            displayMessage("Tüm kullanıcıların kalıcı iksir bonusları başarıyla sıfırlandı.");
        } else {
            displayMessage("Sıfırlanacak iksir bonusuna sahip hiçbir kullanıcı bulunamadı.");
        }

    } catch (error) {
        console.error("Toplu iksir bonusu sıfırlama hatası:", error);
        displayMessage("İşlem sırasında bir hata meydana geldi: " + error.message);
    }
}

// YENİ EKLENECEK KOD BAŞLANGICI

let potionCapsCache = {}; // İksir limitlerini önbellekte tutmak için

/**
 * Admin panelindeki iksir limiti ayarlarını veritabanından yükler ve input'lara yazar.
 */
async function loadPotionCapsForAdmin() {
    if (!isAdmin) return;
    const capsRef = db.ref('gameConfig/potionCaps');
    const capsSnap = await capsRef.once('value');
    const caps = capsSnap.val() || {};

    document.getElementById('potionCapHp').value = caps.hp || '';
    document.getElementById('potionCapDamage').value = caps.damage || '';
    document.getElementById('potionCapDefense').value = caps.defense || '';
    document.getElementById('potionCapCritDamage').value = caps.critDamage || '';
    document.getElementById('potionCapDodge').value = caps.dodgeChance || '';
    document.getElementById('potionCapPierce').value = caps.pierceChance || '';
    document.getElementById('potionCapCrit').value = caps.critChance || '';
}

/**
 * Admin panelindeki iksir limiti ayarlarını kaydeder.
 */
async function savePotionCaps() {
    if (!isAdmin) return;
    const caps = {
        hp: parseInt(document.getElementById('potionCapHp').value) || null,
        damage: parseInt(document.getElementById('potionCapDamage').value) || null,
        defense: parseInt(document.getElementById('potionCapDefense').value) || null,
        critDamage: parseFloat(document.getElementById('potionCapCritDamage').value) || null,
        dodgeChance: parseFloat(document.getElementById('potionCapDodge').value) || null,
        pierceChance: parseFloat(document.getElementById('potionCapPierce').value) || null,
        critChance: parseFloat(document.getElementById('potionCapCrit').value) || null,
    };
    await db.ref('gameConfig/potionCaps').set(caps);
    displayMessage("İksir bonus limitleri başarıyla kaydedildi.");
}

/**
 * Bir kullanıcının belirli bir iksiri alıp alamayacağını ve ne kadar alabileceğini kontrol eder.
 * @param {object} userData Kullanıcının tam verisi.
 * @param {string} potionType 'health_potion', 'damage_potion' gibi iksir tipi.
 * @param {number} amountToAdd Eklenmek istenen miktar.
 * @returns {object} { canAdd: boolean, amount: number, isCapped: boolean }
 */
function checkPotionCap(userData, potionType, amountToAdd) {
    const statKeyMap = { 
        health_potion: 'hp', damage_potion: 'damage', defense_potion: 'defense', 
        crit_potion: 'critChance', crit_damage_potion: 'critDamage', 
        dodge_potion: 'dodgeChance', pierce_potion: 'pierceChance' 
    };
    const statKey = statKeyMap[potionType];
    if (!statKey) return { canAdd: true, amount: amountToAdd, isCapped: false }; // Bilinmeyen iksir türü, limitleme

    const cap = potionCapsCache[statKey];
    // Eğer bu stat için bir limit belirlenmemişse, tam miktarı eklemesine izin ver
    if (cap === undefined || cap === null) {
        return { canAdd: true, amount: amountToAdd, isCapped: false };
    }

    const currentBonus = userData.globalPotionBuffs?.[statKey] || 0;
    
    // Kullanıcı zaten limitte veya limiti geçmişse, hiçbir şey ekleyemez
    if (currentBonus >= cap) {
        return { canAdd: false, amount: 0, isCapped: true };
    }

    const potentialTotal = currentBonus + amountToAdd;
    // Eğer eklenecek miktar limiti aşmıyorsa, tam miktarı eklemesine izin ver
    if (potentialTotal <= cap) {
        return { canAdd: true, amount: amountToAdd, isCapped: false };
    } 
    // Eğer eklenecek miktar limiti aşıyorsa, sadece limite ulaşacak kadarını eklemesine izin ver
    else {
        const amountCanAdd = cap - currentBonus;
        return { canAdd: true, amount: amountCanAdd, isCapped: true };
    }
}

// useHealthRegenPotion fonksiyonunu bununla değiştir
async function useHealthRegenPotion() {
    const selector = document.getElementById('regenPotionSelector');
    const useButton = document.getElementById('useRegenPotionBtn');

    if (useButton) useButton.disabled = true;

    try {
        const userRef = db.ref(`users/${currentUser}`);
        const battleRef = db.ref('gameConfig/monsterBattle');

        const [userSnap, battleSnap] = await Promise.all([userRef.once('value'), battleRef.once('value')]);
        
        const userData = userSnap.val();
        const battleData = battleSnap.val();
        const playerBattleData = battleData?.damageLeaderboard?.[currentUser];

        const regenPotions = userData.inventory?.health_regen_potion || {};
        const hasPotions = Object.values(regenPotions).some(count => count > 0);
        const playerCurrentHP = playerBattleData?.currentHP || 0;
        const isPlayerDead = playerCurrentHP <= 0;
        
        const playerAvatarUrl = playerBattleData?.lockedAvatarUrl || userData.selectedAvatar?.url || defaultAvatarUrl;
        const sanitizedPlayerAvatarId = sanitizeFirebaseKey(playerAvatarUrl);
        const playerMaxHP = (avatarBaseStats[sanitizedPlayerAvatarId]?.hp || 1000) + (userData.globalPotionBuffs?.hp || 0);
        const isPlayerFullHealth = playerCurrentHP >= playerMaxHP;
        const selectedValue = selector.value;

        if (isPlayerDead) {
            throw new Error("Mağlup durumdayken can iksiri kullanamazsın!");
        }
        if (!hasPotions) {
            // GÜNCELLEME BURADA
            displayMessageWithRedirect("Mevcut can yenileme iksirin yok.", "Mağazaya Git", () => {
                storeFilter = { type: 'health_regen_potion' };
                showSection('store');
            });
            throw new Error("İşlem iptal edildi.");
        }
        if (isPlayerFullHealth) {
            throw new Error("Canın zaten dolu olduğu için iksir kullanamazsın.");
        }
        if (!selectedValue) {
            throw new Error("Lütfen kullanmak için bir iksir seç.");
        }

        const percentage = parseInt(selectedValue);
        const potionCount = userData.inventory?.health_regen_potion?.[percentage] || 0;
        if (potionCount < 1) {
            throw new Error(`Kullanmak istediğin %${percentage} iksirinden kalmamış.`);
        }

        const healingAmount = Math.floor(playerMaxHP * (percentage / 100));
        const newHP = Math.min(playerMaxHP, playerCurrentHP + healingAmount);
        const actualHeal = newHP - playerCurrentHP;

        const updates = {};
        updates[`/users/${currentUser}/inventory/health_regen_potion/${percentage}`] = potionCount - 1;
        updates[`/gameConfig/monsterBattle/damageLeaderboard/${currentUser}/currentHP`] = newHP;
        
        await db.ref().update(updates);

        displayMessage(`Başarılı! ${actualHeal} can yeniledin.`);
        
        logActivity('useRegenPotion', currentUser, { 
            percentage: percentage, 
            healed: actualHeal,
            newHP: newHP,
            playerMaxHP: playerMaxHP
        });

    } catch (error) {
        if (error.message !== "İşlem iptal edildi.") {
            displayMessage(error.message);
        }
    } finally {
        if (useButton) useButton.disabled = false;
        handlePotionSelectionChange();
    }
}

      // --- YENİ VE ÇALIŞAN FONKSİYON ---
async function saveAvatarStats() {
    if (!isAdmin) return;

    const confirmed = await customConfirm("Tüm avatarların temel istatistiklerini kaydetmek istediğinize emin misiniz? Bu işlem, tüm avatarların özelliklerini güncelleyecektir.");
    if (!confirmed) return;

    const updates = {};
    let hasError = false;

    document.querySelectorAll('#avatarStatEditor .p-3').forEach(row => {
        if (hasError) return;
        const avatarId = row.dataset.avatarId;
        if (!avatarId) return;

        // Sayısal değerleri alırken ondalık sayılar için virgülü noktaya çeviriyoruz
        const hp = parseInt(row.querySelector('.stat-hp').value);
        const minDamage = parseInt(row.querySelector('.stat-min-damage').value);
        const maxDamage = parseInt(row.querySelector('.stat-max-damage').value);
        const defense = parseInt(row.querySelector('.stat-defense').value);
        const critDamage = parseFloat(String(row.querySelector('.stat-crit-damage').value).replace(',', '.'));
        const dodgeChance = parseFloat(String(row.querySelector('.stat-dodge').value).replace(',', '.'));
        const pierceChance = parseFloat(String(row.querySelector('.stat-pierce').value).replace(',', '.'));
        const critChance = parseFloat(String(row.querySelector('.stat-crit').value).replace(',', '.'));
        
        // Eğer bir alanda geçersiz bir değer varsa (NaN), kullanıcıyı uyar ve işlemi durdur.
        if (isNaN(hp) || isNaN(minDamage) || isNaN(maxDamage) || isNaN(defense) || isNaN(critDamage) || isNaN(dodgeChance) || isNaN(pierceChance) || isNaN(critChance)) {
            displayMessage("Lütfen tüm alanları geçerli sayılarla doldurun. Ondalıklı sayılar için nokta (.) kullanın.");
            hasError = true;
            return;
        }
        
        updates[`/gameConfig/avatarBaseStats/${avatarId}`] = {
            hp: hp,
            minDamage: minDamage,
            maxDamage: maxDamage,
            defense: defense,
            critDamage: critDamage,
            dodgeChance: dodgeChance,
            pierceChance: pierceChance,
            critChance: critChance
        };
    });

    if (hasError) return;

    await db.ref().update(updates);
    displayMessage("Tüm avatarların temel istatistikleri başarıyla kaydedildi!");
}

// BU KOD BLOĞUNU let currentActiveSection = 'game'; SATIRININ ALTINA EKLE

let storeFilter = null; // Mağazayı filtrelemek için kullanılacak global değişken

// Canavar sayfasından mağazaya yönlendirir ve iksir filtresini aktif eder
function goToMonsterStore() {
    // Filtreyi 'canavar savaşı' olarak ayarla
    storeFilter = { type: 'monster_battle' };
    // Mağaza bölümünü göster
    showSection('store');
}

// MEVCUT listenForPersistentNotifications FONKSİYONUNU SİLİP BUNU YAPIŞTIR

function listenForPersistentNotifications() {
    if (isAdmin) return;
    const ref = db.ref(`users/${currentUser}/persistentNotifications`);
    
    const callback = (snap) => {
        const notifId = snap.key;
        const notification = snap.val();
        
        if (notification && notification.type) {
            // YENİ EKLENEN KISIM: 'collectionCompleted' tipini yakala
            switch(notification.type) {
                case 'collectionCompleted':
                    showCollectionCompleteModal(notification);
                    break;
                case 'tradesCancelled':
                    displayMessage(notification.message);
                    break;
            }
            // Bildirimi gösterdikten sonra veritabanından sil
            snap.ref.remove();
        }
    };
    
    if (activeListeners.persistentNotifs) {
        activeListeners.persistentNotifs.ref.off('child_added', activeListeners.persistentNotifs.callback);
    }
    activeListeners.persistentNotifs = { ref, event: 'child_added', callback };
    ref.on('child_added', callback);
}

// Koleksiyon tamamlama penceresini gösterir
function showCollectionCompleteModal(notificationData) {
    document.getElementById('collectionCompleteTitle').innerHTML = notificationData.title;
    document.getElementById('collectionCompleteMessage').innerHTML = notificationData.message;
    document.getElementById('collectionCompleteModal').style.display = 'flex';
}

// Koleksiyon tamamlama penceresini kapatır
function closeCollectionCompleteModal() {
    document.getElementById('collectionCompleteModal').style.display = 'none';
}

// Koleksiyon tamamlama penceresini kapatır
function closeCollectionCompleteModal() {
    document.getElementById('collectionCompleteModal').style.display = 'none';
}

// --- YENİ EKLENECEK KOD: GLOBAL İNTERNET BAĞLANTI KONTROLÜ ---

const connectionStatusOverlay = document.getElementById('connectionStatusOverlay');

// Bağlantı koptuğunda çalışacak fonksiyon
function handleOffline() {
    if (connectionStatusOverlay) {
        connectionStatusOverlay.style.display = 'flex';
    }
}

// Bağlantı geri geldiğinde çalışacak fonksiyon
function handleOnline() {
    if (connectionStatusOverlay) {
        connectionStatusOverlay.style.display = 'none';
    }
}

// Tarayıcının online/offline olaylarını dinle
window.addEventListener('offline', handleOffline);
window.addEventListener('online', handleOnline);

// Sayfa ilk yüklendiğinde durumu kontrol et
// Bu, sayfa açıldığında zaten internet yoksa uyarıyı göstermek için gereklidir.
document.addEventListener('DOMContentLoaded', () => {
    if (!navigator.onLine) {
        handleOffline();
    }
});

/**
 * Sohbet panelinin görünürlüğünü açar veya kapatır. (GÜNCELLENDİ)
 */
function toggleChat() {
    const panel = document.getElementById('chatPanel');
    const btn = document.getElementById('chatToggleBtn'); // Butonu da seçiyoruz
    const dot = document.getElementById('chatNotificationDot');
    
    panel.classList.toggle('open');
    btn.classList.toggle('open'); // Butona da 'open' sınıfını ekleyip/kaldırıyoruz
    
    // Panel açıldığında bildirim noktasını gizle
    if (panel.classList.contains('open')) {
        dot.classList.add('hidden');
    }
}

// sendMessage FONKSİYONUNU BUL VE BUNUNLA DEĞİŞTİR
async function sendMessage() {
    const now = getSyncedTime();
    if (chatSettings.slowModeSeconds > 0 && now < lastMessageTimestamp + (chatSettings.slowModeSeconds * 1000)) {
        const remaining = Math.ceil(((lastMessageTimestamp + (chatSettings.slowModeSeconds * 1000)) - now) / 1000);
        displayMessage(`Yavaş mod aktif. Mesaj göndermek için ${remaining} saniye beklemelisin.`);
        return;
    }

    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (text === '') return;

    const userRef = db.ref(`users/${currentUser}`);
    const userSnap = await userRef.once('value');
    const userData = userSnap.val();

    if (!userData && !isAdmin) return;

    if (!isAdmin && userData.chatMutedUntil && userData.chatMutedUntil > now) {
        const remainingMinutes = Math.ceil((userData.chatMutedUntil - now) / 60000);
        displayMessage(`Sohbetten uzaklaştırıldın. Kalan süre: ${remainingMinutes} dakika.`);
        return;
    }

    const messageData = {
        username: currentUser,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        isDeleted: false
    };

    db.ref('chat/messages').push(messageData);
    input.value = '';
    lastMessageTimestamp = now;
}

/**
 * Adminin bir sohbet mesajını silmesini sağlar.
 */
async function deleteChatMessage(messageId) {
    if (!isAdmin) return;
    const confirmed = await customConfirm("Bu sohbet mesajını silmek istediğinize emin misiniz?");
    if (confirmed) {
        await db.ref(`chat/messages/${messageId}`).remove();
    }
}

// listenForChatMessages FONKSİYONUNU BUL VE BUNUNLA DEĞİŞTİR
function listenForChatMessages() {
    const messagesContainer = document.getElementById('chatMessages');
    const chatRef = db.ref('chat/messages').limitToLast(50);

    if (activeListeners.chat) {
        activeListeners.chat.ref.off('value', activeListeners.chat.callback);
    }

    const callback = async (snap) => {
        messagesContainer.innerHTML = '';
        const messages = [];
        
        snap.forEach(childSnap => {
            messages.push({ id: childSnap.key, ...childSnap.val() });
        });

        // Verimlilik için tüm kullanıcıların avatar bilgilerini tek seferde çekelim
        const usernamesInChat = [...new Set(messages.map(m => m.username))];
        const avatarPromises = usernamesInChat.map(username => 
            db.ref(`users/${username}/selectedAvatar/url`).once('value')
        );
        const avatarSnapshots = await Promise.all(avatarPromises);
        const avatarCache = {};
        avatarSnapshots.forEach((avatarSnap, index) => {
            const username = usernamesInChat[index];
            avatarCache[username] = avatarSnap.val() || defaultAvatarUrl;
        });
        // Admin avatarını da ekle
        avatarCache['WeizendTv'] = 'https://i.hizliresim.com/mtwdr1x.png';

        messages.reverse().forEach(message => {
            const messageEl = document.createElement('div');
            messageEl.className = 'chat-message';
            if (message.username === currentUser) {
                messageEl.classList.add('current-user');
            }

            const adminControls = (isAdmin && message.username !== currentUser) ? `
                <button class="delete-msg-btn" onclick="openAdminChatActionModal('${message.id}', '${message.username}')" title="Mesaj Eylemleri">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" /></svg>
                </button>` : '';
                
            let messageBodyHtml = '';
            let messageBodyClass = 'message-body';

            if (message.isDeleted) {
                if (message.deletedInfo && message.deletedInfo.reason === 'muted') {
                    messageBodyHtml = `[Mesaj silindi - Kullanıcı ${message.deletedInfo.duration} dakika uzaklaştırıldı]`;
                } else {
                    messageBodyHtml = '[Mesaj Admin Tarafından Silindi]';
                }
                messageBodyClass += ' deleted-message-body';
            } else {
                const safeText = message.text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                messageBodyHtml = safeText.replace(/@(\w+)/g, (match, username) => {
                    return `<span class="user-mention" onclick="openPublicUserDetailModal('${username}')">${match}</span>`;
                });
            }

            // Avatarı önbellekten al
            const finalAvatarUrl = avatarCache[message.username];

            messageEl.innerHTML = `
                <img src="${finalAvatarUrl}" class="avatar" onclick="openAvatarStatsModal('${message.username}')">
                <div class="message-content">
                    <div class="message-header">
                        <span class="username" onclick="openPublicUserDetailModal('${message.username}')">${message.username}</span>
                        <span class="timestamp">${new Date(message.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                        ${adminControls}
                    </div>
                    <div class="${messageBodyClass}">${messageBodyHtml}</div>
                </div>
            `;
            messagesContainer.appendChild(messageEl);
        });

        const panel = document.getElementById('chatPanel');
        const lastMessage = messages[0];
        if (lastMessage && !panel.classList.contains('open') && lastMessage.username !== currentUser) {
            document.getElementById('chatNotificationDot').classList.remove('hidden');
        }
    };
    
    activeListeners.chat = { ref: chatRef, event: 'value', callback };
    chatRef.on('value', callback);

    document.getElementById('chatInput').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    document.getElementById('chatInput').addEventListener('input', handleChatInput);
}

/**
 * Admin için 'Mesajı Sil / Kullanıcıyı Uzaklaştır' penceresini açar.
 */
function openAdminChatActionModal(messageId, username) {
    chatMuteTarget = { messageId, username }; // Hedef bilgileri global değişkene ata
    document.getElementById('adminActionTitle').textContent = `${username} | Eylem Seç`;
    document.getElementById('adminDeleteMessageBtn').onclick = () => confirmDeleteMessage(messageId);
    document.getElementById('adminMuteUserBtn').onclick = () => openMuteUserModal(username);
    document.getElementById('adminChatActionModal').style.display = 'flex';
}

function closeAdminChatActionModal() {
    document.getElementById('adminChatActionModal').style.display = 'none';
}

/**
 * Tek bir sohbet mesajını 'silindi' olarak işaretler.
 */
async function confirmDeleteMessage(messageId) {
    await db.ref(`chat/messages/${messageId}`).update({ isDeleted: true });
    displayMessage("Mesaj başarıyla silindi.");
    closeAdminChatActionModal();
    // Arayüzün güncellenmesi için sohbet dinleyicisini yeniden başlatıyoruz.
    listenForChatMessages(); 
}

/**
 * Kullanıcıyı uzaklaştırmak için süre girme penceresini açar.
 */
function openMuteUserModal(username) {
    closeAdminChatActionModal(); // Önceki pencereyi kapat
    document.getElementById('muteUserTitle').textContent = `${username} Adlı Kullanıcıyı Uzaklaştır`;
    document.getElementById('muteUserModal').style.display = 'flex';
}

function closeMuteUserModal() {
    document.getElementById('muteUserModal').style.display = 'none';
    chatMuteTarget = {}; // Hedefi temizle
}

async function confirmMuteUser() {
    const durationMinutes = parseInt(document.getElementById('muteDurationInput').value);
    const usernameToMute = chatMuteTarget.username;

    if (isNaN(durationMinutes) || durationMinutes <= 0) {
        displayMessage("Lütfen geçerli bir süre girin.");
        return;
    }

    const muteUntilTimestamp = getSyncedTime() + (durationMinutes * 60 * 1000);
    
    await db.ref(`users/${usernameToMute}`).update({ chatMutedUntil: muteUntilTimestamp });

    const messagesRef = db.ref('chat/messages');
    const userMessagesSnap = await messagesRef.orderByChild('username').equalTo(usernameToMute).once('value');
    
    if (userMessagesSnap.exists()) {
        const updates = {};
        userMessagesSnap.forEach(childSnap => {
            // YENİ: SİLİNME BİLGİSİNİ DETAYLI OLARAK KAYDET
            updates[`/chat/messages/${childSnap.key}/isDeleted`] = true;
            updates[`/chat/messages/${childSnap.key}/deletedInfo`] = {
                reason: 'muted',
                duration: durationMinutes
            };
        });
        await db.ref().update(updates);
    }
    
    displayMessage(`${usernameToMute} adlı kullanıcı ${durationMinutes} dakika boyunca sohbetten uzaklaştırıldı ve tüm mesajları silindi.`);
    closeMuteUserModal();
    // Arayüzün güncellenmesi için sohbet dinleyicisini yeniden başlatmıyoruz, 'value' listener bunu otomatik yapacak.
}

/**
 * YENİ: Adminin tüm sohbet geçmişini temizlemesini sağlar.
 */
async function clearChatHistory() {
    if (!isAdmin) return;
    const confirmed = await customConfirm("Tüm sohbet geçmişini kalıcı olarak silmek istediğinizden emin misiniz? Bu işlem geri alınamaz!");
    if (confirmed) {
        await db.ref('chat/messages').remove();
        displayMessage("Sohbet geçmişi başarıyla temizlendi.");
        // 'value' listener sayesinde arayüz anında güncellenecek.
    }
}

// YENİ: Yavaş mod ayarlarını Firebase'den dinler
function listenForChatSettings() {
    const ref = db.ref('gameConfig/chat');
    const callback = (snap) => {
        chatSettings = snap.val() || { slowModeSeconds: 3 };
        // Admin paneli açıksa input'u güncelle
        if (adminPanelModal.style.display === 'flex') {
            document.getElementById('slowModeInput').value = chatSettings.slowModeSeconds || '';
        }
    };
    if (activeListeners.chatSettings) {
        ref.off('value', activeListeners.chatSettings.callback);
    }
    activeListeners.chatSettings = { ref, event: 'value', callback };
    ref.on('value', callback);
}

// YENİ: Adminin yavaş mod ayarlarını kaydetmesini sağlar
async function saveSlowModeSettings() {
    if (!isAdmin) return;
    const seconds = parseInt(document.getElementById('slowModeInput').value) || 0;
    if (seconds < 0) {
        displayMessage("Saniye 0'dan küçük olamaz.");
        return;
    }
    await db.ref('gameConfig/chat/slowModeSeconds').set(seconds);
    displayMessage(`Sohbet yavaş modu ${seconds > 0 ? seconds + ' saniye' : 'kapatıldı'} olarak ayarlandı.`);
}

// YENİ: Son Eylemler panelindeki bir aktiviteyi sohbette paylaşır
async function shareActivityToChat(buttonElement) {
    const activityText = buttonElement.dataset.activityText;
    if (!activityText) return;

    const confirmed = await customConfirm(`Bu eylemi sohbette paylaşmak istediğine emin misin?<br><br><small class="text-gray-400">"${activityText}"</small>`);
    if (confirmed) {
        const userSnap = await db.ref(`users/${currentUser}`).once('value');
        const userData = userSnap.val();
        const avatarUrl = userData.selectedAvatar ? userData.selectedAvatar.url : defaultAvatarUrl;

        const messageData = {
            username: currentUser,
            text: activityText, // Eylem metnini doğrudan kullan
            avatarUrl: avatarUrl,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isDeleted: false
        };

        db.ref('chat/messages').push(messageData);
        displayTemporaryNotification("Eylem sohbette paylaşıldı!", 'bg-green-600');
    }
}

// =======================================================
// YENİ ÖZELLİK: AVATAR KODEKSİ SİSTEMİ
// =======================================================

let avatarCodexCache = {}; // Kodeks bilgilerini (nasıl elde edilir vb.) önbellekte tutar

// ESKİ openAvatarCodexModal FONKSİYONUNU BUNUNLA DEĞİŞTİR
async function openAvatarCodexModal() {
    const modal = document.getElementById('avatarCodexModal');
    const grid = document.getElementById('avatarCodexGrid');

    // --- YENİ EKLENEN KISIM BAŞLANGICI ---
    // Eğer kullanıcı admin ise, yönetim panelini açma butonunu görünür yap.
    if (isAdmin) {
        document.getElementById('codexAdminBtn').classList.remove('hidden');
    } else {
        document.getElementById('codexAdminBtn').classList.add('hidden');
    }
    // --- YENİ EKLENEN KISIM SONU ---

    grid.innerHTML = '<p class="text-center col-span-full text-gray-400">Avatarlar yükleniyor...</p>';
    modal.style.display = 'flex';

    try {
        const [codexSnap, statsSnap] = await Promise.all([
            db.ref('gameConfig/avatarCodex').once('value'),
            db.ref('gameConfig/avatarBaseStats').once('value')
        ]);

        const codexData = codexSnap.val() || {};
        avatarCodexCache = codexData; // Cache'i güncelle
        const statsData = statsSnap.val() || {};

        if (Object.keys(codexData).length === 0) {
            grid.innerHTML = '<p class="text-center col-span-full">Henüz kodekse eklenmiş bir avatar bulunmuyor.</p>';
            return;
        }

        grid.innerHTML = '';

        const sortedAvatars = Object.entries(codexData).sort((a, b) => (a[1].order || 0) - (b[1].order || 0));

        for (const [sanitizedId, avatarInfo] of sortedAvatars) {
            const avatarCard = document.createElement('div');
            avatarCard.className = 'relative p-2 rounded-lg cursor-pointer transition-transform hover:scale-105 bg-gray-800';
            // Değişecek satır:
avatarCard.onclick = () => showAvatarDetails(sanitizedId, true);

            avatarCard.innerHTML = `
                <img src="${avatarInfo.imageUrl}" alt="${avatarInfo.name}" class="w-full h-auto rounded-md object-cover aspect-square">
                <p class="text-xs mt-2 text-white font-bold truncate">${avatarInfo.name}</p>
                <div class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                    <span class="text-white text-xs font-bold">Detaylar</span>
                </div>
            `;
            grid.appendChild(avatarCard);
        }

    } catch (error) {
        console.error("Avatar Kodeksi yüklenirken hata:", error);
        grid.innerHTML = '<p class="text-center col-span-full text-red-500">Avatarlar yüklenemedi.</p>';
    }
}

/**
 * Avatar Kodeksi ana penceresini kapatır.
 */
function closeAvatarCodexModal() {
    document.getElementById('avatarCodexModal').style.display = 'none';
}

// ESKİ removeAvatarFromCodex FONKSİYONUNU BUNUNLA DEĞİŞTİR
async function removeAvatarFromCodex(sanitizedId) {
    if (!isAdmin) return;

    const confirmed = await customConfirm(
        "Bu avatarı Kodeks'ten ve istatistiklerinden kalıcı olarak kaldırmak istediğinize emin misiniz? <br><br><small>Bu işlem, avatara sahip olan kullanıcılardan avatarı SİLMEZ, sadece listelerden kaldırır.</small>"
    );

    if (confirmed) {
        try {
            const updates = {};
            updates[`/gameConfig/avatarCodex/${sanitizedId}`] = null;
            updates[`/gameConfig/avatarBaseStats/${sanitizedId}`] = null;

            await db.ref().update(updates);

            displayMessage("Avatar Kodeks'ten ve istatistiklerden başarıyla kaldırıldı.");

            // Admin panelini yeniden yükle
            openAdminAvatarCodexModal();

        } catch (error) {
            console.error("Avatar kaldırılırken hata oluştu:", error);
            displayMessage("Avatar kaldırılırken bir hata meydana geldi.");
        }
    }
}

// YENİ KODU YAPIŞTIR ▼
/**
 * Seçilen avatarın detay penceresini açar ve bilgileri doldurur.
 * @param {string} sanitizedId - Avatarın temizlenmiş ID'si.
 * @param {boolean} showObtainMethod - "Nasıl Elde Edilir?" bilgisinin gösterilip gösterilmeyeceği.
 */
function showAvatarDetails(sanitizedId, showObtainMethod = true) {
    const avatarInfo = avatarCodexCache[sanitizedId];
    const avatarStats = avatarBaseStats[sanitizedId] || {};

    if (!avatarInfo) return;

    document.getElementById('detailAvatarImage').src = avatarInfo.imageUrl;
    document.getElementById('detailAvatarName').textContent = avatarInfo.name;
    
    // --- GÜNCELLEME BURADA ---
    const obtainMethodContainer = document.getElementById('detailAvatarObtainMethod').parentElement;
    if (showObtainMethod) {
        document.getElementById('detailAvatarObtainMethod').textContent = avatarInfo.obtainMethod || 'Henüz bir açıklama eklenmemiş.';
        obtainMethodContainer.style.display = 'block';
    } else {
        obtainMethodContainer.style.display = 'none'; // "Nasıl Elde Edilir?" bölümünü gizle
    }
    // --- GÜNCELLEME SONU ---

    const statsEl = document.getElementById('detailAvatarStats');
    statsEl.innerHTML = `
        <p>❤️ Can: <b class="text-white">${formatNumber(avatarStats.hp || 1000)}</b></p>
        <p>⚔️ Hasar: <b class="text-white">${formatNumber(avatarStats.minDamage || 50)} - ${formatNumber(avatarStats.maxDamage || 100)}</b></p>
        <p>🎯 Kritik Hasar: <b class="text-white">+%${(avatarStats.critDamage || 10).toFixed(1)}</b></p>
        <p>🛡️ Savunma: <b class="text-white">%${(avatarStats.defense || 0).toFixed(1)}</b></p>
        <p>💨 Sıyrılma: <b class="text-white">%${(avatarStats.dodgeChance || 5).toFixed(1)}</b></p>
        <p>📌 Delici Vuruş: <b class="text-white">%${(avatarStats.pierceChance || 5).toFixed(1)}</b></p>
        <p>💥 Kritik Şansı: <b class="text-white">%${(avatarStats.critChance || 5).toFixed(1)}</b></p>
    `;

    document.getElementById('avatarDetailModal').style.display = 'flex';
}

/**
 * Avatar detay penceresini kapatır.
 */
function closeAvatarDetailModal() {
    document.getElementById('avatarDetailModal').style.display = 'none';
}

// =======================================================
// YENİ: GÜNCELLENMİŞ AVATAR KODEKSİ ADMİN SİSTEMİ
// =======================================================

let editingAvatarData = null; // Hangi avatarın düzenlendiğini tutar

// MEVCUT openAdminAvatarCodexModal FONKSİYONUNU SİLİP BUNU YAPIŞTIR
async function openAdminAvatarCodexModal() {
    if (!isAdmin) return;
    const listEl = document.getElementById('adminCodexList');
    listEl.innerHTML = '<p class="text-gray-400 text-center">Avatarlar taranıyor ve listeleniyor...</p>';
    document.getElementById('adminAvatarCodexModal').style.display = 'flex';

    // Önceki dinleyiciyi temizle ki tekrar tekrar eklenmesin
    if (activeListeners.adminCodex && activeListeners.adminCodex.ref) {
        activeListeners.adminCodex.ref.off('value', activeListeners.adminCodex.callback);
    }

    const ref = db.ref('gameConfig/avatarCodex');
    const callback = (codexSnap) => {
        const codexData = codexSnap.val() || {};
        if (Object.keys(codexData).length === 0) {
            listEl.innerHTML = '<p class="text-center col-span-full">Kodekste hiç avatar bulunmuyor. Eklemek için "Yeni Avatar Ekle" butonunu kullanın.</p>';
            return;
        }

        const sortedAvatars = Object.entries(codexData).sort((a, b) => (a[1].order || 0) - (b[1].order || 0));
        
        listEl.innerHTML = ''; // Temizle

        sortedAvatars.forEach(([sanitizedId, avatarInfo], index) => {
            const avatarHtml = `
                <div class="admin-codex-item relative p-3 bg-gray-800 rounded-lg border border-gray-700 flex items-center gap-4" data-avatar-id="${sanitizedId}">
                    <img src="${avatarInfo.imageUrl}" class="w-16 h-16 rounded-md object-cover flex-shrink-0 self-center">
                    <div class="admin-codex-info flex-grow">
                        <p class="text-lg font-bold text-white">${avatarInfo.name}</p>
                        <p class="text-xs text-gray-400 whitespace-normal">${avatarInfo.obtainMethod || 'Açıklama yok'}</p>
                    </div>
                    <div class="admin-codex-actions flex items-center gap-2 flex-shrink-0">
                        <div class="flex flex-col gap-1">
                            <button onclick="reorderAvatarInCodex('${sanitizedId}', 'up')" ${index === 0 ? 'disabled' : ''} class="p-1 rounded-full bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg class="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"/></svg>
                            </button>
                            <button onclick="reorderAvatarInCodex('${sanitizedId}', 'down')" ${index === sortedAvatars.length - 1 ? 'disabled' : ''} class="p-1 rounded-full bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg class="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
                            </button>
                        </div>
                        <button onclick="openAvatarCreatorModal('${sanitizedId}')" class="p-2 bg-blue-600 hover:bg-blue-500 rounded-lg text-white" title="Düzenle">✏️</button>
                        <button onclick="removeAvatarFromCodex('${sanitizedId}')" class="p-2 bg-red-700 hover:bg-red-600 rounded-lg text-white" title="Kodeksten Kaldır">🗑️</button>
                    </div>
                </div>
            `;
            listEl.innerHTML += avatarHtml;
        });
    };
    
    // Dinleyiciyi başlat ve referansını kaydet
    ref.on('value', callback);
    activeListeners.adminCodex = { ref, callback };
}

// MEVCUT closeAdminAvatarCodexModal FONKSİYONUNU SİLİP BUNU YAPIŞTIR
function closeAdminAvatarCodexModal() {
    // Paneli kapatmadan önce, açık olan dinleyiciyi durdur
    if (activeListeners.adminCodex && activeListeners.adminCodex.ref) {
        activeListeners.adminCodex.ref.off('value', activeListeners.adminCodex.callback);
        delete activeListeners.adminCodex; // Referansı temizle
    }
    document.getElementById('adminAvatarCodexModal').style.display = 'none';
}
      
/**
 * Avatar ekleme/düzenleme formunu açar.
 */
async function openAvatarCreatorModal(sanitizedId = null) {
    const modal = document.getElementById('avatarCreatorModal');
    const title = document.getElementById('avatarCreatorTitle');
    editingAvatarData = null; // Önceki düzenleme verisini temizle

    // Formu temizle
    document.getElementById('avatarCreatorName').value = '';
    document.getElementById('avatarCreatorImageUrl').value = '';
    document.getElementById('avatarCreatorObtain').value = '';
    document.getElementById('avatarCreatorHp').value = '';
    document.getElementById('avatarCreatorMinDmg').value = '';
    document.getElementById('avatarCreatorMaxDmg').value = '';
    document.getElementById('avatarCreatorCritDmg').value = '';
    document.getElementById('avatarCreatorDefense').value = '';
    document.getElementById('avatarCreatorDodge').value = '';
    document.getElementById('avatarCreatorPierce').value = '';
    document.getElementById('avatarCreatorCrit').value = '';

    if (sanitizedId) {
        // Düzenleme Modu
        title.textContent = 'Avatarı Düzenle';
        
        const [codexSnap, statsSnap] = await Promise.all([
            db.ref(`gameConfig/avatarCodex/${sanitizedId}`).once('value'),
            db.ref(`gameConfig/avatarBaseStats/${sanitizedId}`).once('value')
        ]);
        
        const codexData = codexSnap.val();
        const statsData = statsSnap.val();

        if (codexData) {
            editingAvatarData = { id: sanitizedId, order: codexData.order };
            document.getElementById('avatarCreatorName').value = codexData.name || '';
            document.getElementById('avatarCreatorImageUrl').value = codexData.imageUrl || '';
            document.getElementById('avatarCreatorObtain').value = codexData.obtainMethod || '';
        }
        if (statsData) {
            document.getElementById('avatarCreatorHp').value = statsData.hp || '';
            document.getElementById('avatarCreatorMinDmg').value = statsData.minDamage || '';
            document.getElementById('avatarCreatorMaxDmg').value = statsData.maxDamage || '';
            document.getElementById('avatarCreatorCritDmg').value = statsData.critDamage || '';
            document.getElementById('avatarCreatorDefense').value = statsData.defense || '';
            document.getElementById('avatarCreatorDodge').value = statsData.dodgeChance || '';
            document.getElementById('avatarCreatorPierce').value = statsData.pierceChance || '';
            document.getElementById('avatarCreatorCrit').value = statsData.critChance || '';
        }
    } else {
        // Yeni Ekleme Modu
        title.textContent = 'Yeni Avatar Ekle';
    }

    modal.style.display = 'flex';
}

/**
 * Avatar ekleme/düzenleme formunu kapatır.
 */
function closeAvatarCreatorModal() {
    document.getElementById('avatarCreatorModal').style.display = 'none';
    editingAvatarData = null;
}

// MEVCUT saveAvatarData FONKSİYONUNU SİLİP BUNU YAPIŞTIR
async function saveAvatarData() {
    if (!isAdmin) return;

    try {
        const name = document.getElementById('avatarCreatorName').value.trim();
        const imageUrl = document.getElementById('avatarCreatorImageUrl').value.trim();
        const obtainMethod = document.getElementById('avatarCreatorObtain').value.trim();
        
        if (!name || !imageUrl) {
            throw new Error("Avatar Adı ve Resim URL'si zorunludur.");
        }
        
        const stats = {
            hp: parseInt(document.getElementById('avatarCreatorHp').value) || 1000,
            minDamage: parseInt(document.getElementById('avatarCreatorMinDmg').value) || 50,
            maxDamage: parseInt(document.getElementById('avatarCreatorMaxDmg').value) || 100,
            critDamage: parseFloat(String(document.getElementById('avatarCreatorCritDmg').value).replace(',', '.')) || 10.0,
            defense: parseFloat(String(document.getElementById('avatarCreatorDefense').value).replace(',', '.')) || 0.0,
            dodgeChance: parseFloat(String(document.getElementById('avatarCreatorDodge').value).replace(',', '.')) || 5.0,
            pierceChance: parseFloat(String(document.getElementById('avatarCreatorPierce').value).replace(',', '.')) || 5.0,
            critChance: parseFloat(String(document.getElementById('avatarCreatorCrit').value).replace(',', '.')) || 5.0,
        };

        const sanitizedId = sanitizeFirebaseKey(imageUrl);
        const updates = {};
        
        if (editingAvatarData) {
            // Düzenleme
            updates[`/gameConfig/avatarCodex/${editingAvatarData.id}/name`] = name;
            updates[`/gameConfig/avatarCodex/${editingAvatarData.id}/imageUrl`] = imageUrl;
            updates[`/gameConfig/avatarCodex/${editingAvatarData.id}/obtainMethod`] = obtainMethod;
            updates[`/gameConfig/avatarBaseStats/${editingAvatarData.id}`] = stats;
        } else {
            // Yeni Ekleme
            const codexRef = db.ref('gameConfig/avatarCodex');
            const lastItemSnap = await codexRef.orderByChild('order').limitToLast(1).once('value');
            let nextOrder = 0;
            if (lastItemSnap.exists()) {
                nextOrder = Object.values(lastItemSnap.val())[0].order + 1;
            }

            updates[`/gameConfig/avatarCodex/${sanitizedId}`] = { name, imageUrl, obtainMethod, order: nextOrder };
            updates[`/gameConfig/avatarBaseStats/${sanitizedId}`] = stats;
        }

        await db.ref().update(updates);
        displayMessage(`Avatar '${name}' başarıyla kaydedildi!`);
        closeAvatarCreatorModal();
        // ARTIK BURADA openAdminAvatarCodexModal() ÇAĞIRMIYORUZ! Değişiklik anlık olarak zaten yansıyacak.

    } catch (error) {
        console.error("Avatar kaydedilirken hata:", error);
        displayMessage("Hata: " + error.message);
    }
}

/**
 * Avatarın Kodeks listesindeki sırasını değiştirir.
 */
async function reorderAvatarInCodex(sanitizedId, direction) {
    if (!isAdmin) return;

    const codexRef = db.ref('gameConfig/avatarCodex');
    const codexSnap = await codexRef.orderByChild('order').once('value');
    if (!codexSnap.exists()) return;

    const sortedAvatars = [];
    codexSnap.forEach(snap => {
        sortedAvatars.push({ id: snap.key, ...snap.val() });
    });

    const currentIndex = sortedAvatars.findIndex(avatar => avatar.id === sanitizedId);
    if (currentIndex === -1) return;

    let newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
    if (newIndex < 0 || newIndex >= sortedAvatars.length) return; // Sınırların dışına çıkmayı engelle

    // Elemanları yer değiştir
    [sortedAvatars[currentIndex], sortedAvatars[newIndex]] = [sortedAvatars[newIndex], sortedAvatars[currentIndex]];

    // Tüm liste için yeni 'order' değerlerini hazırla
    const updates = {};
    sortedAvatars.forEach((avatar, index) => {
        updates[`/gameConfig/avatarCodex/${avatar.id}/order`] = index;
    });

    await db.ref().update(updates);
    openAdminAvatarCodexModal(); // Paneli anında yenile
}

// =======================================================
// YENİ GÜNCELLENMİŞ: PAZARI TEMİZLEME (ÜCRET İADESİZ) FONKSİYONU
// =======================================================

/**
 * Aktif tüm takas tekliflerini iptal eder, KARTLARI sahiplerine iade eder. İŞLEM ÜCRETLERİ İADE EDİLMEZ.
 */
async function clearTradeMarketForSeasonEnd() {
    console.log("Sezon sonu: Takas pazarı temizleniyor (ücret iadesiz)...");

    const tradesRef = db.ref('trades');
    const usersRef = db.ref('users');

    const [tradesSnap, usersSnap] = await Promise.all([
        tradesRef.once('value'),
        usersRef.once('value')
    ]);

    if (!tradesSnap.exists()) {
        console.log("Pazarda temizlenecek aktif takas teklifi bulunamadı.");
        return;
    }

    const trades = tradesSnap.val();
    const usersData = usersSnap.val();
    const updates = {};

    for (const tradeId in trades) {
        const trade = trades[tradeId];
        const offerer = trade.offerer;
        const offeredCardId = trade.offeredCardId;

        if (usersData && usersData[offerer]) {
            const userPath = `/users/${offerer}`;
            const userData = usersData[offerer];

            // 1. KART İADESİ: Sadece teklife konulan kartın sayısını 1 artır.
            const currentCardCount = userData.cardCollection?.[offeredCardId]?.count || 0;
            updates[`${userPath}/cardCollection/${offeredCardId}/count`] = currentCardCount + 1;

            // ★★★ DEĞİŞİKLİK BURADA: Ücret iadesi yapan kod bloğu tamamen kaldırıldı. ★★★

            // 2. BİLDİRİM GÜNCELLEMESİ: Kullanıcıya sadece kartının iade edildiğini söyle.
            const notifKey = db.ref().push().key;
            updates[`${userPath}/notifications/${notifKey}`] = {
                message: `Kart sezonu bittiği için pazardaki takas teklifin otomatik olarak iptal edildi ve kartın envanterine iade edildi.`,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };
        }
    }

    // 3. TÜM TEKLİFLERİ SİL
    updates['/trades'] = null;

    if (Object.keys(updates).length > 0) {
        await db.ref().update(updates);
        console.log("Takas pazarı başarıyla temizlendi, kartlar iade edildi (ücretler iade edilmedi).");
    }
}

/**
 * YENİ: Belirtilen kullanıcının kart koleksiyonunu, joker kartlarını ve albüm tamamlama durumunu sıfırlar.
 */
async function resetUserCards(username) {
    if (!isAdmin || !username) return;

    const confirmed = await customConfirm(
        `<b>${username}</b> adlı kullanıcının <b>tüm kart koleksiyonunu, joker kartlarını ve albüm tamamlama durumunu</b> kalıcı olarak sıfırlamak istediğinize emin misiniz? Bu işlem geri alınamaz!`
    );

    if (!confirmed) return;

    try {
        const userRef = db.ref(`users/${username}`);
        
        // Sıfırlanacak verileri tek bir işlemde güncellemek için bir obje hazırlıyoruz.
        const updates = {};
        updates['/cardCollection'] = null;      // Tüm kart koleksiyonunu siler.
        updates['/completedCollection'] = null; // Albüm tamamlama durumunu siler.
        updates['/wildcards'] = 0;              // Joker kart sayısını sıfırlar.

        await userRef.update(updates);
        
        displayMessage(`${username} adlı kullanıcının tüm kart verileri başarıyla sıfırlandı.`);
        
        // Arayüzü anında güncellemek için yönetim penceresini yeniden aç
        openUserManagementModal(event, username);
        
    } catch (error) {
        console.error("Kullanıcının kartları sıfırlanırken hata oluştu:", error);
        displayMessage("Kartlar sıfırlanırken bir hata meydana geldi: " + error.message);
    }
}

// YENİ FONKSİYON (BUNU EKLE)
/**
 * Avatar Kodeksi ve Temel İstatistik verilerini sunucudan çekip önbelleğe alır.
 */
async function loadCodexAndStatsCache() {
    try {
        const [codexSnap, statsSnap] = await Promise.all([
            db.ref('gameConfig/avatarCodex').once('value'),
            db.ref('gameConfig/avatarBaseStats').once('value')
        ]);
        avatarCodexCache = codexSnap.val() || {};
        avatarBaseStats = statsSnap.val() || {};
        console.log("Avatar önbellekleri başarıyla yüklendi.");
    } catch (error) {
        console.error("Avatar önbellekleri yüklenirken hata oluştu:", error);
    }
}

      async function loadAllCardsCache() {
    try {
        const cardsRef = db.ref('gameConfig/cardCollection');
        const snapshot = await cardsRef.once('value');
        allCardsCache = [];
        if (snapshot.exists()) {
            const cardsData = snapshot.val();
            for (const cardId in cardsData) {
                allCardsCache.push({ id: cardId, ...cardsData[cardId] });
            }
            allCardsCache.sort((a, b) => (a.order || 0) - (b.order || 0));
        }
        console.log("Tüm kartlar önbelleğe alındı:", allCardsCache.length, "adet.");
    } catch (error) {
        console.error("Tüm kartlar önbelleğe alınırken hata oluştu:", error);
    }
}

function showQuestion(questionIndex) {
    db.ref(`wordGame/questions/${questionIndex}/isRevealed`).set(true);
}

 // MEVCUT listenForWordGameData FONKSİYONUNU SİLİP BUNU YAPIŞTIRIN
function listenForWordGameData() {
    if (activeWordGameListener) {
        activeWordGameListener.ref.off('value', activeWordGameListener.callback);
    }

    const ref = db.ref('wordGame');
    const callback = (snap) => {
        const gameData = snap.val();
        if (gameData && gameData.questions) {
            renderQuestions(gameData.questions);
            renderWordGameLeaderboard(gameData.leaderboard);
            renderWordGameStatsAndPrize(gameData); // YENİ EKLENEN SATIR
        } else {
            document.getElementById('questionsContainer').innerHTML = '<p class="text-center text-gray-400 p-4">Adminin yeni bir bulmaca başlatması bekleniyor.</p>';
            document.getElementById('wordGameLeaderboard').innerHTML = '';
            document.getElementById('wordGameStatsContainer').classList.add('hidden'); // YENİ EKLENEN SATIR
        }
    };
    activeWordGameListener = { ref, callback };
    ref.on('value', callback);
    
    if (!isAdmin) {
        const userCooldownRef = db.ref(`users/${currentUser}/wordGameCooldown`);
        userCooldownRef.on('value', snap => handleCooldown(snap.val()));
    }
}

function renderQuestions(questionsData) {
    const container = document.getElementById('questionsContainer');
    container.innerHTML = '';
    const isCoolingDown = wordGameCooldownEnd > getSyncedTime();
    let previousQuestionSolved = true;

    questionsData.forEach((question, qIndex) => {
        // Eğer önceki soru çözülmediyse, bu ve sonraki soruları gösterme
        if (!previousQuestionSolved) return;

        const isCurrentQuestionSolved = (question.letters || []).every(letter => letter.solved);

        const questionBlock = document.createElement('div');
        questionBlock.className = 'question-block';
        
        // Soru metnini ve cevap kutularını oluştur
        let contentHtml = `
            <p class="text-lg text-gray-300 mb-4">${qIndex + 1}. Soru: <b class="text-white">${question.text}</b></p>
            <div class="answer-letters-container">
        `;
        
        (question.letters || []).forEach((letter, lIndex) => {
            if (letter.solved) {
                // Çözülmüş harf kutusu
                contentHtml += `
                    <div class="answer-letter solved" onclick="showSolvedBoxInfo(${qIndex}, ${lIndex})">
                        ${letter.char}
                        
                        <span class="reward-icon" title="${formatRewardText(letter.reward.type, letter.reward.amount || letter.reward.value)}">${getRewardIcon(letter.reward.type)}</span>
                    </div>`;
            } else {
                // ★★★ DEĞİŞİKLİK BURADA ★★★
                // Çözülmemiş harf kutusu (bekleme süresindeyse kalan süreyi gösterir, değilse harf girme penceresini açar)
                const onClickAction = isCoolingDown ? `onclick="showCooldownMessage()"` : `onclick="openLetterInputModal(${qIndex}, ${lIndex})"`;
                contentHtml += `<div class="answer-letter unsolved" ${onClickAction}></div>`;
            }
        });

        contentHtml += `</div>`;
        questionBlock.innerHTML = contentHtml;
        container.appendChild(questionBlock);

        // Bir sonraki döngü için bu sorunun çözülüp çözülmediğini kaydet
        previousQuestionSolved = isCurrentQuestionSolved;
    });
}

/**
 * YENİ: Kelime oyunu bekleme süresindeyken kapalı bir kutuya tıklandığında bilgilendirme mesajı gösterir.
 */
function showCooldownMessage() {
    if (wordGameCooldownEnd > getSyncedTime()) {
        const remainingSeconds = Math.ceil((wordGameCooldownEnd - getSyncedTime()) / 1000);
        const durationText = formatDurationFromSeconds(remainingSeconds);
        displayMessage(`Tekrar harf girebilmek için beklemen gerekiyor. Kalan süre: <b class="text-yellow-300">${durationText}</b>`);
    }
}
   
function renderWordGameLeaderboard(leaderboardData) {
    const leaderboardEl = document.getElementById('wordGameLeaderboard');
    if (!leaderboardData) {
        leaderboardEl.innerHTML = '<p class="text-center text-gray-500">Henüz kimse harf çözmedi.</p>';
        return;
    }

    const sorted = Object.entries(leaderboardData).sort((a, b) => b[1].score - a[1].score);
    
    let html = '';
    sorted.forEach(([username, data], index) => {
        const avatarUrl = data.avatarUrl || defaultAvatarUrl;
        html += `
            <div class="flex items-center p-2 bg-gray-800 rounded-md">
                <span class="font-bold text-lg text-gray-400 w-8 text-center">${index + 1}.</span>
                <img src="${avatarUrl}" class="w-10 h-10 rounded-full object-cover ml-2 mr-4 cursor-pointer" onclick="openPublicUserDetailModal('${username}')">
                <div class="flex-grow">
                    <p class="font-bold text-white cursor-pointer hover:underline" onclick="openPublicUserDetailModal('${username}')">${username}</p>
                    <p class="text-sm text-yellow-300">${data.score} Harf</p>
                </div>
            </div>
        `;
    });
    leaderboardEl.innerHTML = html;
}

function openLetterInputModal(qIndex, lIndex) {
    // ★★★ DEĞİŞİKLİK BURADA ★★★
    // Bekleme süresi bitmeden bu pencerenin açılmasını engelleyen ek kontrol.
    if (wordGameCooldownEnd > getSyncedTime()) {
        showCooldownMessage(); // Kalan süreyi göster
        return;
    }

    const modal = document.getElementById('letterInputModal');
    const input = document.getElementById('letterInput');
    modal.dataset.qIndex = qIndex;
    modal.dataset.lIndex = lIndex;
    input.value = '';
    modal.style.display = 'flex';
    input.focus();
}

function closeLetterInputModal() {
    document.getElementById('letterInputModal').style.display = 'none';
}

async function submitLetter() {
    if (isAdmin) {
        displayMessage("Adminler oyun oynayamaz.");
        closeLetterInputModal();
        return;
    }

    const modal = document.getElementById('letterInputModal');
    const input = document.getElementById('letterInput');
    const letter = input.value.trim().toLocaleUpperCase('tr-TR');
    const qIndex = parseInt(modal.dataset.qIndex);
    const lIndex = parseInt(modal.dataset.lIndex);

    if (letter.length !== 1 || !/^[A-ZÇĞİÖŞÜ]$/.test(letter)) {
        displayMessage("Lütfen geçerli tek bir harf girin.");
        return;
    }

    closeLetterInputModal();

    const cellRef = db.ref(`wordGame/questions/${qIndex}/letters/${lIndex}`);
    const userRef = db.ref(`users/${currentUser}`);
    
    // Bekleme süresi panelini ve içeriğini en baştan alalım
    const cooldownInfoEl = document.getElementById('wordGameCooldownInfo');
    const cooldownTextEl = cooldownInfoEl.childNodes[0]; // "Yanlış harf girdin..." metni

    try {
        const { committed, snapshot } = await cellRef.transaction(letterData => {
            if (letterData && !letterData.solved) {
                if (letterData.char === letter) {
                    letterData.solved = true;
                    letterData.solver = currentUser;
                    letterData.solvedAt = firebase.database.ServerValue.TIMESTAMP;
                }
                return letterData;
            }
            return; 
        });

        if (committed) {
            const finalLetterData = snapshot.val();
            if (finalLetterData.solved && finalLetterData.solver === currentUser) {
                // --- DOĞRU CEVAP VERİLDİ ---
                
                // 1. Panelin rengini ve yazısını DEĞİŞTİR
                cooldownTextEl.textContent = 'Tekrar harf yazmak için beklemen gereken süre: ';
                cooldownInfoEl.className = 'text-center bg-blue-900/50 border border-blue-500 text-blue-300 p-3 rounded-lg mb-4';

                const reward = finalLetterData.reward;
                const rewardText = formatRewardText(reward.type, reward.amount || reward.value, reward.uses);
                
                const correctCooldownSeconds = (await db.ref('wordGame/settings/correctGuessCooldown').once('value')).val() || 60;
                await userRef.update({
                    wordGameCooldown: getSyncedTime() + (correctCooldownSeconds * 1000)
                });
                const durationText = formatDurationFromSeconds(correctCooldownSeconds);
                displayMessage(`Harf doğru! Kazandığın ödül: <b class="text-green-400">${rewardText}</b><br><small class="text-yellow-300">${durationText} bekleme süren başladı.</small>`);
                
                let cardPacksToOpen = [];
                let newBalance; 

                await userRef.transaction(userData => {
                    if (userData) {
                        const result = applyRewardToUser(userData, reward);
                        cardPacksToOpen.push(...result.cardPacksToOpen);
                        newBalance = userData.balance; 
                    }
                    return userData;
                });
                
                const leaderboardRef = db.ref(`wordGame/leaderboard/${currentUser}`);
                const userAvatar = (await userRef.child('selectedAvatar/url').once('value')).val() || defaultAvatarUrl;
                await leaderboardRef.transaction(currentData => ({
                    score: (currentData?.score || 0) + 1,
                    avatarUrl: userAvatar
                }));

                const logDetails = { letter: letter, rewardText: rewardText };
                if (reward.type === 'points') logDetails.newBalance = newBalance; 
                logActivity('wordGameGuess', currentUser, logDetails);
                
                for (const pack of cardPacksToOpen) {
                    await startCardPackOpening(pack.value || 1, 'Kelime Oyunu', 1, pack.type);
                }
                
                if (!isAdmin) {
                    checkForGameCompletionAndAwardChampion();
                }

            } else {
                // --- YANLIŞ CEVAP VERİLDİ ---
                
                // 1. Panelin rengini ve yazısını ORİJİNAL HALİNE GETİR
                cooldownTextEl.textContent = 'Yanlış harf girdin! Tekrar denemek için beklemen gereken süre: ';
                cooldownInfoEl.className = 'text-center bg-red-900/50 border border-red-500 text-red-300 p-3 rounded-lg mb-4';
                
                const cooldownSeconds = (await db.ref('wordGame/settings/cooldown').once('value')).val() || 60;
                await userRef.update({
                    wordGameCooldown: getSyncedTime() + (cooldownSeconds * 1000)
                });
                const durationText = formatDurationFromSeconds(cooldownSeconds);
                displayMessage(`Harf yanlış! ${durationText} sonra tekrar deneyebilirsin.`);

                logActivity('wordGameWrongGuess', currentUser, {
                    letter: letter,
                    cooldown: cooldownSeconds
                });
            }
        } else {
            const competitorData = (await cellRef.once('value')).val();
            if (competitorData && competitorData.solver) {
                displayMessage(`Bu kutuyu senden hemen önce <b class="text-yellow-300">${competitorData.solver}</b> çözdü!`);
            }
        }
    } catch (error) {
        console.error("Harf gönderme hatası:", error);
        displayMessage("Bir hata oluştu.");
    }
}

function handleCooldown(cooldownEndTimestamp) {
    if (wordGameCooldownInterval) clearInterval(wordGameCooldownInterval);
    const infoEl = document.getElementById('wordGameCooldownInfo');
    const timerEl = document.getElementById('wordGameCooldownTimer');
    
    // ▼▼▼ YENİ EKLENEN KISIM BAŞLANGICI ▼▼▼
    // Eğer kullanıcı admin ise, zamanlayıcıyı kesinlikle gösterme ve durdur.
    if (isAdmin) {
        infoEl.classList.add('hidden');
        wordGameCooldownEnd = 0;
        return;
    }
    // ▲▲▲ YENİ EKLENEN KISIM SONU ▲▲▲
    
    wordGameCooldownEnd = cooldownEndTimestamp || 0;

    const updateTimer = () => {
        const now = getSyncedTime();
        if (now >= wordGameCooldownEnd) {
            infoEl.classList.add('hidden');
            clearInterval(wordGameCooldownInterval);
            listenForWordGameData(); 
        } else {
            const remainingSeconds = Math.ceil((wordGameCooldownEnd - now) / 1000);
            timerEl.textContent = formatDurationFromSeconds(remainingSeconds);
            infoEl.classList.remove('hidden');
        }
    };
    
    if (wordGameCooldownEnd > getSyncedTime()) {
        updateTimer();
        wordGameCooldownInterval = setInterval(updateTimer, 1000);
    } else {
        infoEl.classList.add('hidden');
    }
}

// MEVCUT showSolvedBoxInfo FONKSİYONUNU SİL VE BUNUNLA DEĞİŞTİR

async function showSolvedBoxInfo(qIndex, lIndex) {
    const letterSnap = await db.ref(`wordGame/questions/${qIndex}/letters/${lIndex}`).once('value');
    const letterData = letterSnap.val();
    if (!letterData) return;

    const contentEl = document.getElementById('solvedBoxInfoContent');
    
    // ★★★ DEĞİŞEN SATIR BAŞLANGICI ★★★
    // Artık formatRewardText fonksiyonuna 3. parametre olarak "letterData.reward.uses" değerini de gönderiyoruz.
    const rewardText = formatRewardText(letterData.reward.type, letterData.reward.amount || letterData.reward.value, letterData.reward.uses);
    // ★★★ DEĞİŞEN SATIR SONU ★★★

    contentEl.innerHTML = `
        <p>Çözen: <b class="text-white cursor-pointer hover:underline" onclick="openPublicUserDetailModal('${letterData.solver}')">${letterData.solver}</b></p>
        <p>Harf: <b class="text-white">${letterData.char}</b></p>
        <p>Kazanılan Ödül: <b class="text-green-400">${rewardText}</b></p>
        <p class="text-xs text-gray-400 mt-2">${new Date(letterData.solvedAt).toLocaleString('tr-TR')}</p>
    `;
    document.getElementById('solvedBoxInfoModal').style.display = 'flex';
}

function closeSolvedBoxInfoModal() {
    document.getElementById('solvedBoxInfoModal').style.display = 'none';
}

function closeWordGameAdminModal() {
    document.getElementById('wordGameAdminModal').style.display = 'none';
}

function addQuestionBlock() {
    const container = document.getElementById('questionBlocksContainer');
    const block = document.createElement('div');
    block.className = 'p-3 bg-gray-900/50 rounded-lg border border-gray-700';
    block.innerHTML = `
        <div class="flex justify-between items-center mb-2">
            <label class="text-gray-300">Soru & Cevap</label>
            <button onclick="this.parentElement.parentElement.remove()" class="py-1 px-2 bg-red-600 hover:bg-red-500 rounded-md text-xs">Bu Soruyu Sil</button>
        </div>
        <textarea class="box-setting-input question-text mb-2" rows="2" placeholder="Soru metnini buraya yazın..."></textarea>
        <input type="text" class="box-setting-input answer-text uppercase" placeholder="CEVAP" oninput="generateRewardFields(this)">
        <div class="letter-rewards-container mt-2 space-y-2"></div>
    `;
    container.appendChild(block);
}

   // MEVCUT openWordGameAdminModal FONKSİYONUNU SİLİP BUNU YAPIŞTIR
async function openWordGameAdminModal() {
    if (!isAdmin) return;
    const container = document.getElementById('questionBlocksContainer');
    container.innerHTML = '<p class="text-center text-gray-400">Mevcut oyun ayarları yükleniyor...</p>';
    document.getElementById('wordGameAdminModal').style.display = 'flex';

    const gameSnap = await db.ref('wordGame').once('value');
    const gameData = gameSnap.val();

    container.innerHTML = ''; // Paneli temizle

    // Yanlış cevap bekleme süresini yükle
    const cooldownSecondsTotal = (gameData && gameData.settings) ? gameData.settings.cooldown || 60 : 60;
    const days = Math.floor(cooldownSecondsTotal / 86400);
    let remainder = cooldownSecondsTotal % 86400;
    const hours = Math.floor(remainder / 3600);
    remainder %= 3600;
    const minutes = Math.floor(remainder / 60);
    const seconds = remainder % 60;
    document.getElementById('cooldownDays').value = days > 0 ? days : '';
    document.getElementById('cooldownHours').value = hours > 0 ? hours : '';
    document.getElementById('cooldownMinutes').value = minutes > 0 ? minutes : '';
    document.getElementById('cooldownSeconds').value = seconds > 0 ? seconds : '';

    // YENİ EKLENEN KISIM: Doğru cevap bekleme süresini yükle
    const correctCooldownSecondsTotal = (gameData && gameData.settings) ? gameData.settings.correctGuessCooldown || 60 : 60;
    const cDays = Math.floor(correctCooldownSecondsTotal / 86400);
    let cRemainder = correctCooldownSecondsTotal % 86400;
    const cHours = Math.floor(cRemainder / 3600);
    cRemainder %= 3600;
    const cMinutes = Math.floor(cRemainder / 60);
    const cSeconds = cRemainder % 60;
    document.getElementById('correctCooldownDays').value = cDays > 0 ? cDays : '';
    document.getElementById('correctCooldownHours').value = cHours > 0 ? cHours : '';
    document.getElementById('correctCooldownMinutes').value = cMinutes > 0 ? cMinutes : '';
    document.getElementById('correctCooldownSeconds').value = cSeconds > 0 ? cSeconds : '';
    // YENİ KISIM SONU

    if (gameData && gameData.questions && gameData.questions.length > 0) {
        gameData.questions.forEach(questionData => {
            addQuestionBlock(questionData);
        });
    } else {
        addQuestionBlock();
    }
    
    loadWordGameChampionPrize();
}

function addQuestionBlock(questionData = null) {
    const container = document.getElementById('questionBlocksContainer');
    const block = document.createElement('div');
    block.className = 'p-3 bg-gray-900/50 rounded-lg border border-gray-700';
    
    // Veri varsa input'ları doldur, yoksa boş bırak
    const questionText = questionData ? questionData.text : '';
    const answerText = questionData ? questionData.answer : '';

    block.innerHTML = `
        <div class="flex justify-between items-center mb-2">
            <label class="text-gray-300">Soru & Cevap</label>
            <button onclick="this.parentElement.parentElement.remove()" class="py-1 px-2 bg-red-600 hover:bg-red-500 rounded-md text-xs">Bu Soruyu Sil</button>
        </div>
        <textarea class="box-setting-input question-text mb-2" rows="2" placeholder="Soru metnini buraya yazın...">${questionText}</textarea>
        <input type="text" class="box-setting-input answer-text uppercase" placeholder="CEVAP" value="${answerText}" oninput="generateRewardFields(this)">
        <div class="letter-rewards-container mt-2 space-y-2"></div>
    `;
    container.appendChild(block);

    // Eğer veri varsa, ödül alanlarını da bu veriye göre oluştur
    if (questionData) {
        generateRewardFields(block.querySelector('.answer-text'), questionData.letters);
    }
}

function generateRewardFields(answerInput, lettersData = null) {
    const answer = answerInput.value.trim().toLocaleUpperCase('tr-TR').replace(/[^A-ZÇĞİÖŞÜ]/g, '');
    answerInput.value = answer; 
    const container = answerInput.parentElement.querySelector('.letter-rewards-container');
    container.innerHTML = '';

    for (let i = 0; i < answer.length; i++) {
        const letter = answer[i];
        const rewardData = lettersData ? lettersData[i]?.reward : {};
        
        // Önce her satır için bir ana taşıyıcı element oluşturuyoruz
        const wrapperDiv = document.createElement('div');
        wrapperDiv.className = 'flex items-center gap-2';

        // Satırın içeriğini HTML olarak bu elemente ekliyoruz
        wrapperDiv.innerHTML = `
            <span class="font-bold text-yellow-300 w-8 text-center text-lg">${letter}</span>
            ${getRewardItemHTML(`reward_${i}`, rewardData)}
        `;
        
        // Tamamlanmış satırı ana konteynere ekliyoruz
        container.appendChild(wrapperDiv);

        // Şimdi, YALNIZCA YENİ EKLEDİĞİMİZ SATIRIN içindeki elementleri bularak
        // doğru input'ların görünmesini sağlayan fonksiyonu çağırıyoruz.
        const newRow = wrapperDiv.querySelector('.reward-entry');
        if (newRow) {
            handleAdminRewardTypeChange(newRow.querySelector('.reward-type'), rewardData);
        }
    }
}

// MEVCUT saveWordGameSettings FONKSİYONUNU SİLİP BUNU YAPIŞTIR
async function saveWordGameSettings(shouldResetProgress = false) {
    if (!isAdmin) return;
    
    let confirmationMessage = '';
    if (shouldResetProgress) {
        confirmationMessage = "Bu işlem mevcut bulmacayı tamamen silip yenisini oluşturacak ve liderlik tablosunu sıfırlayacaktır. Emin misiniz?";
    } else {
        confirmationMessage = "Mevcut kelime oyunu ayarlarını bu şekilde güncellemek istediğinize emin misiniz? <br><br><small class='text-yellow-300'>Bu işlem oyuncuların mevcut serilerini SIFIRLAMAZ, sadece ödülleri günceller.</small>";
    }
    // saveWordGameSettings fonksiyonundaki if (shouldResetProgress) bloğunun içine ekle
logActivity('event', 'WeizendTv', { eventType: 'wordgame', status: 'started' }, 'etkinlikler');
    
    const confirmed = await customConfirm(confirmationMessage);
    if (!confirmed) return;

    try {
        const oldGameSnap = await db.ref('wordGame').once('value');
        const oldGameData = oldGameSnap.val();

        const questions = [];
        const questionBlocks = document.querySelectorAll('#questionBlocksContainer > div');
        let hasError = false;

        for (const [qIndex, block] of questionBlocks.entries()) {
            if (hasError) continue;
            const questionText = block.querySelector('.question-text').value.trim();
            const answer = block.querySelector('.answer-text').value.trim().toLocaleUpperCase('tr-TR');
            
            if (!questionText || !answer) continue;

            const letters = [];
            const rewardRows = block.querySelectorAll('.letter-rewards-container .reward-entry');
            if (rewardRows.length !== answer.length) {
                hasError = true;
                throw new Error(`'${questionText}' sorusunun cevabındaki harf sayısı ile ödül sayısı eşleşmiyor!`);
            }

            for (let i = 0; i < answer.length; i++) {
                const char = answer[i];
                const reward = parseRewardDataFromRow(rewardRows[i]);
                if (!reward) {
                    hasError = true;
                    throw new Error(`'${questionText}' sorusundaki '${char}' harfinin ödülü geçersiz.`);
                }
                
                let letterState = {
                    char: char,
                    reward: reward,
                    solved: false,
                    solver: null,
                    solvedAt: null
                };

                if (!shouldResetProgress && oldGameData && oldGameData.questions && oldGameData.questions[qIndex]) {
                    const oldQuestion = oldGameData.questions[qIndex];
                    if (oldQuestion.answer === answer && oldQuestion.letters[i] && oldQuestion.letters[i].solved) {
                        letterState.solved = true;
                        letterState.solver = oldQuestion.letters[i].solver;
                        letterState.solvedAt = oldQuestion.letters[i].solvedAt;
                    }
                }
                letters.push(letterState);
            }
            questions.push({ text: questionText, answer: answer, letters: letters });
        }
        
        if (hasError) return;

        // Yanlış cevap bekleme süresini al
        const days = parseInt(document.getElementById('cooldownDays').value) || 0;
        const hours = parseInt(document.getElementById('cooldownHours').value) || 0;
        const minutes = parseInt(document.getElementById('cooldownMinutes').value) || 0;
        const seconds = parseInt(document.getElementById('cooldownSeconds').value) || 0;
        const totalCooldownSeconds = (days * 86400) + (hours * 3600) + (minutes * 60) + seconds;

        // YENİ EKLENEN KISIM: Doğru cevap bekleme süresini al
        const cDays = parseInt(document.getElementById('correctCooldownDays').value) || 0;
        const cHours = parseInt(document.getElementById('correctCooldownHours').value) || 0;
        const cMinutes = parseInt(document.getElementById('correctCooldownMinutes').value) || 0;
        const cSeconds = parseInt(document.getElementById('correctCooldownSeconds').value) || 0;
        const totalCorrectCooldownSeconds = (cDays * 86400) + (cHours * 3600) + (cMinutes * 60) + cSeconds;
        // YENİ KISIM SONU

        const updates = {};
        updates['/wordGame/settings'] = {
            cooldown: totalCooldownSeconds,
            correctGuessCooldown: totalCorrectCooldownSeconds // Yeni ayarı kaydet
        };
        updates['/wordGame/questions'] = questions;

        if (shouldResetProgress) {
            updates['/wordGame/leaderboard'] = null; 
            updates['/gameStats/wordGameChampion'] = null; // Şampiyonu da sıfırla
            
            const usersSnap = await db.ref('users').once('value');
            if (usersSnap.exists()) {
                usersSnap.forEach(user => {
                    if (user.val().wordGameCooldown) {
                        updates[`/users/${user.key}/wordGameCooldown`] = null;
                    }
                });
            }

            displayMessage("Kelime Oyunu başarıyla sıfırlandı ve yeni ayarlarla başlatıldı!");
        } else {
            displayMessage("Kelime Oyunu ayarları başarıyla güncellendi. Oyuncuların ilerlemesi korundu.");
        }

        await db.ref().update(updates);
        closeWordGameAdminModal();

    } catch (error) {
        displayMessage(`Hata: ${error.message}`);
    }
}

async function resetWordGame() {
    if (!isAdmin) return;
    const confirmed = await customConfirm("Tüm bulmacayı ve liderlik tablosunu sıfırlamak istediğinize emin misiniz?");
    if (confirmed) {
        await db.ref('wordGame').remove();
        displayMessage("Kelime oyunu başarıyla sıfırlandı.");
        closeWordGameAdminModal();
    }
}

function getRewardIcon(type) {
    // ★★★ DEĞİŞİKLİK BURADA: Eksik olan tüm ikonlar eklendi ★★★
    const iconMap = {
        points: '💰',
        boxRights: '📦',
        wheelTicket: '🎫',
        clickCatchTicket: '🎟️',
        iflasShield: '🛡️',
        tempMultiplier: '✖️',
        wildcard: '🃏',
        card_pack: '🎴',
        card_pack_normal: '🥉',
        card_pack_gumus: '🥈',
        card_pack_altin: '🥇',
        card_pack_efsanevi: '🏆',
        revival_stone: '💎',
        health_potion: '🧪',
        damage_potion: '⚔️',
        defense_potion: '🛡️',
        crit_potion: '💥',
        crit_damage_potion: '🎯',
        dodge_potion: '💨',
        pierce_potion: '📌',
        health_regen_potion: '🧪'
    };
    return iconMap[type] || '🎁'; // Eşleşme bulunamazsa varsayılan olarak hediye paketi göster
}

/**
 * Saniyeyi "X gün Y saat Z dakika W saniye" formatına çevirir.
 * Sıfır olan birimleri atlar (örn: 0 gün demez).
 * @param {number} totalSeconds - Çevrilecek toplam saniye.
 * @returns {string} Biçimlendirilmiş zaman metni.
 */
function formatDurationFromSeconds(totalSeconds) {
    if (totalSeconds <= 0) {
        return "0 saniye";
    }

    const days = Math.floor(totalSeconds / 86400);
    totalSeconds %= 86400;
    const hours = Math.floor(totalSeconds / 3600);
    totalSeconds %= 3600;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60); // Math.floor ekledik

    const parts = [];
    if (days > 0) parts.push(`${days} gün`);
    if (hours > 0) parts.push(`${hours} saat`);
    if (minutes > 0) parts.push(`${minutes} dakika`);
    if (seconds > 0) parts.push(`${seconds} saniye`);

    // Eğer hiçbir parça yoksa (çok küçük bir saniye değeri için), 0 saniye döndür
    return parts.length > 0 ? parts.join(' ') : "0 saniye";
}

// YENİ EKLENECEK FONKSİYONLAR BAŞLANGICI

/**
 * Kelime Oyunu şampiyonunu ve ödülünü Firebase'den dinler ve paneli günceller.
 */
function listenForWordGameChampion() {
    const ref = db.ref('gameStats/wordGameChampion');
    const panel = document.getElementById('wordGameChampionPanel');

    const callback = snap => {
        const data = snap.val();
        if (!data || !data.username) {
            panel.classList.add('hidden');
            return;
        }

        const adminDeleteButton = isAdmin ? `
            <button onclick="db.ref('gameStats/wordGameChampion').remove()" class="absolute -top-3 -right-3 bg-red-600 hover:bg-red-500 text-white rounded-full h-8 w-8 flex items-center justify-center text-lg font-bold" title="Şampiyon Panelini Gizle">&times;</button>
        ` : '';

        const championHtml = `
            ${adminDeleteButton}
            <h4 class="text-green-300 text-xl font-bold mb-3">🎯 Kelime Avcısı Şampiyonu 🎯</h4>
            <div class="flex items-center justify-center gap-4">
                <img src="${data.avatarUrl}" class="w-16 h-16 rounded-full border-2 border-yellow-300 object-cover cursor-pointer" onclick="openAvatarStatsModal('${data.username}')">
                <div>
                    <p class="text-xl font-bold text-white cursor-pointer hover:underline" onclick="openPublicUserDetailModal('${data.username}')">${data.username}</p>
                    <p class="text-gray-300">Toplam Çözülen: <b class="text-yellow-400">${data.score} Harf</b></p>
                    <p class="text-gray-300">Ödül: <b class="text-green-400">${data.prizeAwarded}</b></p>
                </div>
            </div>
        `;

        panel.innerHTML = championHtml;
        panel.classList.remove('hidden');
    };
    
    if (activeListeners.wordGameChampion) {
        activeListeners.wordGameChampion.ref.off('value', activeListeners.wordGameChampion.callback);
    }
    activeListeners.wordGameChampion = { ref, event: 'value', callback };
    ref.on('value', callback);
}

/**
 * Admin: Kelime oyunu şampiyonu için ödül ayarlarını kaydeder.
 */
async function saveWordGameChampionPrize() {
    if (!isAdmin) return;
    const container = document.getElementById('wordGameChampionPrizeContainer');
    const reward = parseRewardDataFromRow(container.querySelector('.reward-entry'));
    if (reward) {
        await db.ref('wordGame/settings/championPrize').set(reward);
        displayMessage("Kelime Oyunu şampiyon ödülü başarıyla kaydedildi.");
    } else {
        displayMessage("Hata: Geçersiz ödül bilgileri girildi.");
    }
}

/**
 * Admin: Kayıtlı şampiyon ödülünü yükler ve paneli oluşturur.
 */
async function loadWordGameChampionPrize() {
    const container = document.getElementById('wordGameChampionPrizeContainer');
    const prizeSnap = await db.ref('wordGame/settings/championPrize').once('value');
    const prizeData = prizeSnap.val() || {};
    
    container.innerHTML = getRewardItemHTML('champion_prize', prizeData);
    const selectElement = container.querySelector('.reward-type');
    if (selectElement) {
        handleAdminRewardTypeChange(selectElement, prizeData);
    }
    // Kaydet butonu
    container.innerHTML += `<button onclick="saveWordGameChampionPrize()" class="w-full mt-2 py-2 bg-blue-700 hover:bg-blue-600 text-white font-bold rounded-lg md:col-span-3">Şampiyon Ödülünü Kaydet</button>`;
}

/**
 * Tüm harfler çözüldüğünde şampiyonu belirler ve ödülünü verir.
 */
async function checkForGameCompletionAndAwardChampion() {
    // Önce şampiyonun zaten belirlenip belirlenmediğini kontrol et
    const existingChampionSnap = await db.ref('gameStats/wordGameChampion').once('value');
    if (existingChampionSnap.exists()) {
        console.log("Oyun şampiyonu zaten belirlenmiş, işlem atlandı.");
        return;
    }
    
    const gameSnap = await db.ref('wordGame').once('value');
    const gameData = gameSnap.val();
    
    if (!gameData || !gameData.questions) return;

    const allSolved = gameData.questions.every(q => q.letters.every(l => l.solved));

    if (allSolved) {
        console.log("Tüm harfler çözüldü! Şampiyon belirleniyor...");
        const leaderboard = gameData.leaderboard;
        if (!leaderboard) return;

        const sorted = Object.entries(leaderboard).sort((a, b) => b[1].score - a[1].score);
        if (sorted.length === 0) return;

        const winnerUsername = sorted[0][0];
        const winnerData = sorted[0][1];
        
        const prizeData = gameData.settings?.championPrize;
        if (!prizeData) {
            console.log("Şampiyon ödülü ayarlanmamış, ödül verilemedi.");
            return;
        }

        const prizeText = formatRewardText(prizeData.type, prizeData.amount || prizeData.value, prizeData.uses);

        // Şampiyon bilgilerini kaydet
        await db.ref('gameStats/wordGameChampion').set({
            username: winnerUsername,
            score: winnerData.score,
            prizeAwarded: prizeText,
            avatarUrl: winnerData.avatarUrl,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });

        // Ödülü kullanıcıya ver
        const userRef = db.ref(`users/${winnerUsername}`);
        await userRef.transaction(userData => {
            if (userData) {
                applyRewardToUser(userData, prizeData);
            }
            return userData;
        });

        // Aktivite kaydı
        logActivity('wordGameChampion', winnerUsername, { score: winnerData.score, prize: prizeText });
        // checkForGameCompletionAndAwardChampion fonksiyonundaki logActivity('wordGameChampion'...) satırının altına ekle
logActivity('event', 'WeizendTv', { eventType: 'wordgame', status: 'finished', winner: winnerUsername }, 'etkinlikler');

    }
}

   // --- YENİ EKLENECEK BİLGİ PENCERESİ FONKSİYONLARI ---

function openCraftingInfoModal() {
    document.getElementById('craftingInfoModal').style.display = 'flex';
}
function closeCraftingInfoModal() {
    document.getElementById('craftingInfoModal').style.display = 'none';
}
function openWordGameInfoModal() {
    document.getElementById('wordGameInfoModal').style.display = 'flex';
}
function closeWordGameInfoModal() {
    document.getElementById('wordGameInfoModal').style.display = 'none';
}

   // YENİ EKLENECEK FONKSİYON: Kelime oyunu istatistiklerini ve ödülünü ekrana yazar.
function renderWordGameStatsAndPrize(gameData) {
    const container = document.getElementById('wordGameStatsContainer');
    if (!gameData || !gameData.questions || gameData.questions.length === 0) {
        container.classList.add('hidden');
        return;
    }

    const questions = gameData.questions;
    const totalQuestions = questions.length;
    const solvedQuestions = questions.filter(q => (q.letters || []).every(l => l.solved)).length;
    const remainingQuestions = totalQuestions - solvedQuestions;

    document.getElementById('totalQuestionsStat').textContent = totalQuestions;
    document.getElementById('solvedQuestionsStat').textContent = solvedQuestions;
    document.getElementById('remainingQuestionsStat').textContent = remainingQuestions;

    const prize = gameData.settings?.championPrize;
    const prizeEl = document.getElementById('wordGameChampionPrize');
    if (prize) {
        prizeEl.textContent = formatRewardText(prize.type, prize.amount || prize.value, prize.uses);
    } else {
        prizeEl.textContent = 'Henüz belirlenmedi';
    }

    container.classList.remove('hidden');
}
   
// YENİ EKLENECEK FONKSİYONLAR SONU
</script>
</body>
</html>
