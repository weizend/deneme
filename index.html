function listenForEventsTab() {
    // Referanslara ÅŸampiyon verilerini de ekliyoruz.
    const eventRefs = [
        db.ref('gameConfig/monsterBattle'),        // 0
        db.ref('clickCatchLobby'),                 // 1
        db.ref('gameConfig/weeklyClickCatchReset'),// 2
        db.ref('wordGame'),                        // 3
        db.ref('gameConfig/cardCollectionStatus'), // 4
        db.ref('gameStats/wordGameChampion'),      // 5
        db.ref('gameStats/weeklyClickCatchWinner'),// 6
    ];

    const renderEvents = async () => {
        const container = document.getElementById('activityFeedTab-etkinlikler');
        container.innerHTML = '<p class="text-center text-gray-400">Etkinlik durumu kontrol ediliyor...</p>';

        const snapshots = await Promise.all(eventRefs.map(ref => ref.once('value')));
        
        let html = '';
        
        const monsterData = snapshots[0].val();
        const lobbyData = snapshots[1].val();
        const weeklyData = snapshots[2].val();
        const wordGameData = snapshots[3].val();
        const collectionStatus = snapshots[4].val();
        const wordGameChampionData = snapshots[5].val();
        const weeklyWinnerData = snapshots[6].val();

        // 1. Canavar SavaÅŸÄ±
        if (monsterData && monsterData.monsterDetails) {
            if (monsterData.monsterDetails.currentHP > 0) {
                // Etkinlik devam ediyor...
                const sortedLeaderboard = Object.entries(monsterData.damageLeaderboard || {}).sort((a,b) => b[1].totalDamage - a[1].totalDamage);
                const leader = sortedLeaderboard.length > 0 ? sortedLeaderboard[0] : null;
                const leaderText = leader ? `1. sÄ±rada <b class="text-white">${leader[0]}</b> (${formatNumber(leader[1].totalDamage)} Hasar)` : '1. sÄ±ra iÃ§in oyuncu bekleniyor.';
                const prize = monsterData.rewards?.onKillLeader;
                const prizeText = prize ? `${formatNumber(prize.value)} ${typeToName[prize.type]}` : 'Belirlenmedi';

                html += `
                    <div class="event-card ongoing">
                        <h5 class="font-bold text-white mb-2">Canavar SavaÅŸÄ± EtkinliÄŸi BaÅŸladÄ±!</h5>
                        <p class="text-sm text-gray-300"><b class="text-red-400">${monsterData.monsterDetails.name}</b> canavarÄ± arenaya geldi.</p>
                        <p class="text-sm text-gray-300">Liderlik Ã–dÃ¼lÃ¼: <b class="text-green-400">${prizeText}</b></p>
                        <p class="text-sm text-gray-300 mt-2">${leaderText}</p>
                        <p class="text-xs text-lime-400 font-bold mt-1">Etkinlik devam ediyor</p>
                    </div>`;
            } else {
                // Etkinlik bitti...
                html += `
                    <div class="event-card finished">
                        <h5 class="font-bold text-white mb-2">Canavar SavaÅŸÄ± EtkinliÄŸi Bitti!</h5>
                        <p class="text-sm text-gray-400">Åampiyon seÃ§ildi ve etkinlik bitti. YÃ¶neticinin etkinliÄŸi yeniden baÅŸlatmasÄ± bekleniyor.</p>
                    </div>`;
            }
        }
        
        // 2. TÄ±kla-Yakala Lobi (Sadece aktifken gÃ¶sterilir)
        if (lobbyData && (lobbyData.state === 'waiting' || lobbyData.state === 'active')) {
             const stateText = lobbyData.state === 'waiting' ? 'KatÄ±lÄ±mcÄ± Bekleniyor' : 'Etkinlik devam ediyor';
             const katilimText = lobbyData.entryTickets > 0 ? `${lobbyData.entryTickets} Bilet` : `${lobbyData.entryFee} Puan`;
             html += `
                <div class="event-card ongoing">
                    <h5 class="font-bold text-white mb-2">TÄ±kla-Yakala Lobi EtkinliÄŸi BaÅŸladÄ±!</h5>
                    <p class="text-sm text-gray-300">KatÄ±lÄ±m: <b class="text-yellow-400">${katilimText}</b> | Ã–dÃ¼l: <b class="text-green-400">${formatNumber(lobbyData.prize)} Puan</b></p>
                    <p class="text-xs text-lime-400 font-bold mt-1">${stateText}</p>
                </div>`;
        }
        
        // 3. TÄ±kla-Yakala HaftalÄ±k
        if (weeklyData && weeklyData.endDate) {
            const prize = weeklyData.prize;
            const prizeText = prize.type === 'special' ? prize.name : `${formatNumber(prize.amount)} ${typeToName[prize.type]}`;
            const scoresSnap = await db.ref('clickCatchWeeklyScores').orderByValue().limitToLast(1).once('value');
            let leaderText = '1. sÄ±ra iÃ§in oyuncu bekleniyor.';
            if (scoresSnap.exists()) {
                const leaderUsername = Object.keys(scoresSnap.val())[0];
                const leaderScore = scoresSnap.val()[leaderUsername];
                leaderText = `1. sÄ±rada <b class="text-white">${leaderUsername}</b> (${formatNumber(leaderScore)} Skor)`;
            }

            html += `
                <div class="event-card ongoing">
                    <h5 class="font-bold text-white mb-2">TÄ±kla-Yakala HaftalÄ±k EtkinliÄŸi</h5>
                    <p class="text-sm text-gray-300">HaftanÄ±n Åampiyonu Ã–dÃ¼lÃ¼: <b class="text-green-400">${prizeText}</b></p>
                    <p class="text-sm text-gray-300 mt-2">${leaderText}</p>
                    <p class="text-xs text-lime-400 font-bold mt-1">Etkinlik devam ediyor</p>
                </div>`;
        } else if (weeklyWinnerData) {
             html += `
                <div class="event-card finished">
                    <h5 class="font-bold text-white mb-2">TÄ±kla-Yakala HaftalÄ±k EtkinliÄŸi Bitti!</h5>
                    <p class="text-sm text-gray-400">Åampiyon seÃ§ildi ve etkinlik bitti. YÃ¶neticinin etkinliÄŸi yeniden baÅŸlatmasÄ± bekleniyor.</p>
                </div>`;
        }

        // 4. Kelime Oyunu
        if (wordGameData && wordGameData.questions) {
            if (wordGameChampionData) {
                 html += `
                <div class="event-card finished">
                    <h5 class="font-bold text-white mb-2">Kelime Oyunu EtkinliÄŸi Bitti!</h5>
                    <p class="text-sm text-gray-400">Åampiyon seÃ§ildi ve etkinlik bitti. YÃ¶neticinin etkinliÄŸi yeniden baÅŸlatmasÄ± bekleniyor.</p>
                </div>`;
            } else {
                const sortedLeaderboard = Object.entries(wordGameData.leaderboard || {}).sort((a,b) => b[1].score - a[1].score);
                const leader = sortedLeaderboard.length > 0 ? sortedLeaderboard[0] : null;
                const leaderText = leader ? `1. sÄ±rada <b class="text-white">${leader[0]}</b> (${leader[1].score} Harf)` : '1. sÄ±ra iÃ§in oyuncu bekleniyor.';
                const prize = wordGameData.settings?.championPrize;
                const prizeText = prize ? formatRewardText(prize.type, prize.amount || prize.value, prize.uses) : 'Belirlenmedi';
                 html += `
                    <div class="event-card ongoing">
                        <h5 class="font-bold text-white mb-2">Kelime Oyunu EtkinliÄŸi BaÅŸladÄ±!</h5>
                        <p class="text-sm text-gray-300">Åampiyon Ã–dÃ¼lÃ¼: <b class="text-green-400">${prizeText}</b></p>
                        <p class="text-sm text-gray-300 mt-2">${leaderText}</p>
                        <p class="text-xs text-lime-400 font-bold mt-1">Etkinlik devam ediyor</p>
                    </div>`;
            }
        }

        // 5. Kart Koleksiyonu
        if (collectionStatus === 'active') {
             const prizeSnap = await db.ref('gameConfig/collectionGrandPrize').once('value');
             const prize = prizeSnap.val();
             const prizeText = prize && prize.description ? prize.description : "BÃ¼yÃ¼k Ã–dÃ¼l";
             
             const finishersSnap = await db.ref('gameStats/collectionFinishers').once('value');
             let leaderText = 'HenÃ¼z kimse albÃ¼mÃ¼ tamamlamadÄ±.';
             if (finishersSnap.exists()) {
                 const firstFinisher = Object.values(finishersSnap.val()).sort((a,b) => a.timestamp - b.timestamp)[0];
                 leaderText = `1. sÄ±rada <b class="text-white">${firstFinisher.username}</b> (TamamladÄ±)`;
             }

             html += `
                <div class="event-card ongoing">
                    <h5 class="font-bold text-white mb-2">Kart Koleksiyonu EtkinliÄŸi BaÅŸladÄ±!</h5>
                    <p class="text-sm text-gray-300">BÃ¼yÃ¼k Ã–dÃ¼l: <b class="text-green-400">${prizeText}</b></p>
                    <p class="text-sm text-gray-300 mt-2">${leaderText}</p>
                    <p class="text-xs text-lime-400 font-bold mt-1">Sezon Devam Ediyor</p>
                </div>`;
        }

        container.innerHTML = html || '<p class="text-center text-gray-400 p-4">Åu anda aktif bir etkinlik bulunmuyor.</p>';
    };
    
    // Herhangi bir etkinlik verisi deÄŸiÅŸtiÄŸinde sekme iÃ§eriÄŸini yeniden oluÅŸturulsun diye dinleyicileri ata
    eventRefs.forEach(ref => ref.on('value', renderEvents));
}

// MEVCUT attackMonster FONKSÄ°YONUNU SÄ°LÄ°P BUNU YAPIÅTIR
async function attackMonster() {
    if (isAdmin) {
        displayMessage("Adminler saldÄ±ramaz.");
        return;
    }
    
    if (attackCooldown) return;

    const attackBtn = document.getElementById('attackMonsterBtn');
    
    try {
        const userRef = db.ref(`users/${currentUser}`);
        const battleRef = db.ref('gameConfig/monsterBattle');

        const [userSnap, battleSnap] = await Promise.all([userRef.once('value'), battleRef.once('value')]);
        
        const userData = userSnap.val();
        const battleData = battleSnap.val();

        if (!userData || !battleData || !battleData.monsterDetails || battleData.monsterDetails.currentHP <= 0) {
            throw new Error("SavaÅŸ durumu geÃ§ersiz veya canavar zaten Ã¶lÃ¼.");
        }
        
        const playerBattleData = battleData.damageLeaderboard?.[currentUser];

        if (!playerBattleData) {
            if (!userData.selectedAvatar || !userData.selectedAvatar.url) {
                displayMessage("SavaÅŸa katÄ±lmak iÃ§in Ã¶nce envanterden bir avatar seÃ§melisin!");
                return;
            }
            const confirmed = await customConfirm(
                `Canavara ilk saldÄ±rÄ±nÄ± yapÄ±yorsun! Bu saldÄ±rÄ±dan sonra, ÅŸu an seÃ§ili olan avatarÄ±n bu canavar Ã¶lene kadar kilitlenecek ve deÄŸiÅŸtirilemeyecek. Devam etmek istiyor musun?`
            );
            if (!confirmed) return; 
        }

        if (playerBattleData && playerBattleData.currentHP <= 0) {
            throw new Error("SavaÅŸmak iÃ§in canÄ±n kalmadÄ±! Dirilme TaÅŸÄ± kullanmalÄ±sÄ±n.");
        }
        
        attackCooldown = true;
        attackBtn.disabled = true;

        const playerAvatarUrl = playerBattleData?.lockedAvatarUrl || userData.selectedAvatar?.url || defaultAvatarUrl;
        const sanitizedPlayerAvatarId = sanitizeFirebaseKey(playerAvatarUrl);
        const playerBaseStats = avatarBaseStats[sanitizedPlayerAvatarId] || {};
        const globalBuffs = userData.globalPotionBuffs || {};

        const playerStats = {
            hp: (playerBaseStats.hp || 1000) + (globalBuffs.hp || 0),
            minDamage: (playerBaseStats.minDamage || 50) + (globalBuffs.damage || 0),
            maxDamage: (playerBaseStats.maxDamage || 100) + (globalBuffs.damage || 0),
            defense: (playerBaseStats.defense || 10) + (globalBuffs.defense || 0),
            critChance: (playerBaseStats.critChance || 5) + (globalBuffs.critChance || 0),
            critDamage: (playerBaseStats.critDamage || 10) + (globalBuffs.critDamage || 0),
            dodgeChance: (playerBaseStats.dodgeChance || 5) + (globalBuffs.dodgeChance || 0),
            pierceChance: (playerBaseStats.pierceChance || 5) + (globalBuffs.pierceChance || 0),
        };
        const monsterStats = battleData.monsterDetails;
        
        const monsterDefenseReduction = Math.min((monsterStats.defense || 0) / 100, 0.8);
        const playerDefenseReduction = Math.min((playerStats.defense || 0) / 100, 0.8);

        let finalDamageToMonster = 0;
        let playerAttackType = 'normal';
        const playerPierced = (Math.random() * 100) < playerStats.pierceChance;
        const didMonsterDodge = !playerPierced && (Math.random() * 100) < (monsterStats.dodgeChance || 0);
        let playerAttackDetails = '';

        if (didMonsterDodge) {
            playerAttackDetails = `Canavar saldÄ±rÄ±ndan <b class="text-cyan-400">sÄ±yrÄ±ldÄ±!</b>`;
        } else {
            const playerCritted = (Math.random() * 100) < playerStats.critChance;
            let totalDamage;

            if (playerCritted) {
                totalDamage = playerStats.maxDamage + Math.floor(playerStats.maxDamage * (playerStats.critDamage / 100));
            } else {
                totalDamage = Math.floor(Math.random() * (playerStats.maxDamage - playerStats.minDamage + 1)) + playerStats.minDamage;
            }
            
            if (playerPierced) {
                finalDamageToMonster = playerStats.maxDamage;
                playerAttackType = 'pierce';
                playerAttackDetails = `ğŸ“Œ <b class="text-purple-400">Delici VuruÅŸ</b> ile canavara <b class="text-white">${finalDamageToMonster} hasar</b> verdin.`;
            } else {
                finalDamageToMonster = Math.max(1, Math.floor(totalDamage * (1 - monsterDefenseReduction)));
                if(playerCritted) {
                    playerAttackType = 'crit';
                    playerAttackDetails = `ğŸ’¥ <b class="text-amber-400">Kritik VuruÅŸ</b> ile canavara <b class="text-white">${finalDamageToMonster} hasar</b> verdin.`;
                } else {
                    playerAttackDetails = `Canavara <b class="text-white">${finalDamageToMonster} hasar</b> verdin.`;
                }
            }
        }

        let finalDamageToPlayer = 0;
        let monsterAttackType = 'normal';
        const monsterPierced = (Math.random() * 100) < (monsterStats.pierceChance || 5);
        const didPlayerDodge = !monsterPierced && (Math.random() * 100) < playerStats.dodgeChance;
        let monsterAttackDetails = '';

        if (didPlayerDodge) {
            monsterAttackDetails = `CanavarÄ±n saldÄ±rÄ±sÄ±ndan <b class="text-cyan-400">sÄ±yrÄ±ldÄ±n!</b>`;
        } else {
            const monsterCritted = (Math.random() * 100) < (monsterStats.critChance || 5);
            let totalDamage;

            if (monsterCritted) {
                totalDamage = monsterStats.maxDamage + Math.floor(monsterStats.maxDamage * ((monsterStats.critDamage || 10) / 100));
            } else {
                totalDamage = Math.floor(Math.random() * (monsterStats.maxDamage - monsterStats.minDamage + 1)) + monsterStats.minDamage;
            }

            if (monsterPierced) {
                finalDamageToPlayer = monsterStats.maxDamage;
                monsterAttackType = 'pierce';
                monsterAttackDetails = `ğŸ“Œ Canavar <b class="text-purple-400">delici vuruÅŸla</b> sana <b class="text-red-400">${finalDamageToPlayer} hasar</b> verdi.`;
            } else {
                finalDamageToPlayer = Math.max(1, Math.floor(totalDamage * (1 - playerDefenseReduction)));
                if(monsterCritted) {
                    monsterAttackType = 'crit';
                    monsterAttackDetails = `ğŸ’¥ Canavar <b class="text-amber-400">kritik vuruÅŸla</b> sana <b class="text-red-400">${finalDamageToPlayer} hasar</b> verdi.`;
                } else {
                    monsterAttackDetails = `Canavar sana <b class="text-red-400">${finalDamageToPlayer} hasar</b> verdi.`;
                }
            }
        }
        
        let randomReward = null;
        const damageTiers = (battleData.damageTiers || []).sort((a, b) => b.minDamage - a.minDamage);
        for (const tier of damageTiers) {
            if (finalDamageToMonster >= tier.minDamage) {
                const totalChance = tier.rewards.reduce((sum, r) => sum + r.chance, 0);
                let randomRoll = Math.random() * totalChance;
                for (const reward of tier.rewards) {
                    randomRoll -= reward.chance;
                    if (randomRoll <= 0) { randomReward = reward; break; }
                }
                break; 
            }
        }
        
        let finalPlayerHP = 0;
        let finalMonsterHP = 0;
        let finalTotalPlayerDamage = 0;
        let playerDiedInAttack = false;

        await battleRef.transaction(currentBattleData => {
            if (!currentBattleData || !currentBattleData.monsterDetails || currentBattleData.monsterDetails.currentHP <= 0) return;
            
            finalMonsterHP = Math.max(0, currentBattleData.monsterDetails.currentHP - finalDamageToMonster);
            currentBattleData.monsterDetails.currentHP = finalMonsterHP;

            if (!currentBattleData.damageLeaderboard) currentBattleData.damageLeaderboard = {};
            if (!currentBattleData.damageLeaderboard[currentUser]) {
                currentBattleData.damageLeaderboard[currentUser] = { totalDamage: 0, currentHP: playerStats.hp, lockedAvatarUrl: playerAvatarUrl };
            }

            const currentPlayerBattleData = currentBattleData.damageLeaderboard[currentUser];
            currentPlayerBattleData.totalDamage += finalDamageToMonster;
            finalTotalPlayerDamage = currentPlayerBattleData.totalDamage;
            
            currentPlayerBattleData.currentHP = Math.max(0, currentPlayerBattleData.currentHP - finalDamageToPlayer);
            finalPlayerHP = currentPlayerBattleData.currentHP;
            
            if (finalPlayerHP <= 0) playerDiedInAttack = true;
            return currentBattleData;
        });
        
        const updates = {};
        let rewardMessage = '';
        let rewardLogText = '';
        if (randomReward) {
            const { type, value } = randomReward;
            const prizeName = typeToName[type] || 'Ã–dÃ¼l';
            const isPercent = ['defense_potion', 'crit_potion', 'crit_damage_potion', 'dodge_potion', 'pierce_potion', 'health_regen_potion'].includes(type);
            // â˜…â˜…â˜… Ä°STEÄE GÃ–RE GÃœNCELLENEN MESAJ ALANI â˜…â˜…â˜…
            const valuePrefix = isPercent ? `%` : `+`;
            
            rewardMessage = `<hr class="border-gray-600 my-2">ğŸ‰ <b>Ã–dÃ¼l:</b> <b class="text-green-400">${valuePrefix}${value} ${prizeName}</b> kazandÄ±n!`;
            rewardLogText = `${valuePrefix}${value} ${prizeName}`;
            
            if (type === 'health_regen_potion') {
                const currentPotions = userData.inventory?.health_regen_potion?.[value] || 0;
                updates[`/users/${currentUser}/inventory/health_regen_potion/${value}`] = currentPotions + 1;
            } else {
                const dbKeyMap = { points: 'balance', boxRights: 'kutuHakki', wheelTicket: 'carkBileti', clickCatchTicket: 'clickCatchTickets', iflasShield: 'iflasShieldUses', wildcard: 'wildcards', revival_stone: 'inventory/revival_stone' };
                const statKeyMap = { health_potion: 'hp', damage_potion: 'damage', defense_potion: 'defense', crit_potion: 'critChance', crit_damage_potion: 'critDamage', dodge_potion: 'dodgeChance', pierce_potion: 'pierceChance' };
                if (type === 'points') {
                    updates[`/users/${currentUser}/balance`] = (userData.balance || 0) + value;
                    updates[`/users/${currentUser}/kariyerPuani`] = (userData.kariyerPuani || 0) + value;
                } else if (type.startsWith('card_pack')) {
                     startCardPackOpening(value, 'Canavar SavaÅŸÄ±', 1, type);
                } else if (dbKeyMap[type]) {
                    const path = `/users/${currentUser}/${dbKeyMap[type]}`;
                    const pathParts = dbKeyMap[type].split('/');
                    const currentValue = pathParts.length > 1 ? (userData.inventory?.[pathParts[1]] || 0) : (userData[pathParts[0]] || 0);
                    updates[path] = currentValue + value;
                } else if (statKeyMap[type]) {
                    const statKey = statKeyMap[type];
                    const capCheck = checkPotionCap(userData, type, value);
                    if (capCheck.canAdd && capCheck.amount > 0) {
                        const path = `/users/${currentUser}/globalPotionBuffs/${statKey}`;
                        const currentValue = userData.globalPotionBuffs?.[statKey] || 0;
                        updates[path] = currentValue + capCheck.amount;
                        if(capCheck.isCapped) rewardMessage += ` (Limite ulaÅŸÄ±ldÄ±!)`;
                    } else {
                        rewardMessage += ` (Limitte olduÄŸu iÃ§in kazanÄ±lamadÄ±!)`;
                    }
                }
            }
        }
        if (Object.keys(updates).length > 0) await db.ref().update(updates);
        
        logActivity('monsterAttack', currentUser, {
            monsterName: monsterStats.name,
            damageDealt: finalDamageToMonster,
            damageTaken: finalDamageToPlayer,
            playerAttackType: playerAttackType,
            monsterAttackType: monsterAttackType,
            didPlayerDodge: didPlayerDodge,
            didMonsterDodge: didMonsterDodge,
            playerRemainingHP: finalPlayerHP,
            playerMaxHP: playerStats.hp,
            monsterRemainingHP: finalMonsterHP,
            monsterMaxHP: monsterStats.maxHP,
            playerTotalDamage: finalTotalPlayerDamage,
            rewardWon: rewardLogText,
            playerDied: playerDiedInAttack
        });
        
        let attackInfoMessage = `
            <div class="text-left space-y-2">
                <p><b>Senin SaldÄ±rÄ±n:</b> ${playerAttackDetails}</p>
                <p><b>CanavarÄ±n SaldÄ±rÄ±sÄ±:</b> ${monsterAttackDetails}</p>
                ${rewardMessage}
            </div>
        `;

        showFloatingText(`-${finalDamageToMonster}`, document.getElementById('monsterImage').getBoundingClientRect().left + 100, document.getElementById('monsterImage').getBoundingClientRect().top + 100);
        displayMessage(attackInfoMessage);
        
        const finalBattleSnap = await battleRef.once('value');
        const finalBattleData = finalBattleSnap.val();

        if (finalBattleData && finalBattleData.monsterDetails.currentHP <= 0) {
            const sortedLeaderboard = Object.entries(finalBattleData.damageLeaderboard || {}).sort((a,b) => b[1].totalDamage - a[1].totalDamage);
            const winner = sortedLeaderboard.length > 0 ? sortedLeaderboard[0][0] : null;
            const winnerData = winner ? finalBattleData.damageLeaderboard[winner] : null;
            const prize = finalBattleData.rewards?.onKillLeader;

            if (winner && prize && winnerData) {
                await db.ref('gameStats/lastMonsterChampion').set({
                    username: winner,
                    totalDamage: winnerData.totalDamage,
                    lockedAvatarUrl: winnerData.lockedAvatarUrl
                });

                const prizeName = typeToName[prize.type] || prize.type;
                const prizeText = `${prize.value} ${prizeName}`;
                
                logActivity('monsterDefeated', 'WeizendTv', { 
                    monsterName: finalBattleData.monsterDetails.name, 
                    winner: winner, 
                    prize: prizeText,
                    totalDamage: winnerData.totalDamage
                });
                // attackMonster fonksiyonundaki logActivity('monsterDefeated'...) satÄ±rÄ±nÄ±n altÄ±na ekle
logActivity('event', 'WeizendTv', { eventType: 'monster', status: 'finished', winner: winner }, 'etkinlikler');
                
                const winnerRef = db.ref(`users/${winner}`);
                await winnerRef.transaction(winnerDataFromDB => {
                    if (winnerDataFromDB) {
                         const { type, value } = prize;
                         if(type === 'health_regen_potion'){
                            if(!winnerDataFromDB.inventory) winnerDataFromDB.inventory = {};
                            if(!winnerDataFromDB.inventory.health_regen_potion) winnerDataFromDB.inventory.health_regen_potion = {};
                            const currentPotions = winnerDataFromDB.inventory.health_regen_potion[value] || 0;
                            winnerDataFromDB.inventory.health_regen_potion[value] = currentPotions + 1;
                         } else {
                             const dbKeyMap = { points: 'balance', boxRights: 'kutuHakki', wheelTicket: 'carkBileti', clickCatchTicket: 'clickCatchTickets', iflasShield: 'iflasShieldUses', wildcard: 'wildcards', revival_stone: 'inventory/revival_stone' };
                             const statKeyMap = { health_potion: 'hp', damage_potion: 'damage', defense_potion: 'defense', crit_potion: 'critChance', crit_damage_potion: 'critDamage', dodge_potion: 'dodgeChance', pierce_potion: 'pierceChance' };
                             
                             if (type === 'points') {
                                winnerDataFromDB.balance = (winnerDataFromDB.balance || 0) + value;
                                winnerDataFromDB.kariyerPuani = (winnerDataFromDB.kariyerPuani || 0) + value;
                             } else if (type.startsWith('card_pack')) {
                                 const packKey = db.ref().push().key;
                                 if (!winnerDataFromDB.pendingActions) winnerDataFromDB.pendingActions = {};
                                 if (!winnerDataFromDB.pendingActions.cardPacks) winnerDataFromDB.pendingActions.cardPacks = {};
                                 winnerDataFromDB.pendingActions.cardPacks[packKey] = { type: type, count: value };
                             } else if (dbKeyMap[type]) {
                                 const pathParts = dbKeyMap[type].split('/');
                                 if (pathParts.length > 1) {
                                     if (!winnerDataFromDB[pathParts[0]]) winnerDataFromDB[pathParts[0]] = {};
                                     winnerDataFromDB[pathParts[0]][pathParts[1]] = (winnerDataFromDB[pathParts[0]][pathParts[1]] || 0) + value;
                                 } else {
                                     winnerDataFromDB[dbKeyMap[type]] = (winnerDataFromDB[dbKeyMap[type]] || 0) + value;
                                 }
                             } else if (statKeyMap[type]) {
                                const statKey = statKeyMap[type];
                                const capCheck = checkPotionCap(winnerDataFromDB, type, value);
                                if (capCheck.canAdd && capCheck.amount > 0) {
                                    if (!winnerDataFromDB.globalPotionBuffs) winnerDataFromDB.globalPotionBuffs = {};
                                    winnerDataFromDB.globalPotionBuffs[statKey] = (winnerDataFromDB.globalPotionBuffs[statKey] || 0) + capCheck.amount;
                                }
                             }
                         }

                         if (!winnerDataFromDB.monsterChampionships) {
                             winnerDataFromDB.monsterChampionships = [];
                         }
                         winnerDataFromDB.monsterChampionships.push({
                             timestamp: firebase.database.ServerValue.TIMESTAMP,
                             monsterName: finalBattleData.monsterDetails.name,
                             damage: winnerData.totalDamage
                         });
                    }
                    return winnerDataFromDB;
                });
            }
        }

    } catch (error) {
        displayMessage(error.message);
    } finally {
        let count = 3;
        const interval = setInterval(() => {
            attackBtn.textContent = `BEKLE (${count--})`;
            if (count < 0) {
                clearInterval(interval);
                attackCooldown = false;
                attackBtn.disabled = false;
                attackBtn.textContent = 'SALDIR!';
            }
        }, 1000);
    }
}
      
// YENÄ°: Canavar SavaÅŸÄ± Bilgi Modal'Ä±nÄ± aÃ§ar ve kapatÄ±r
function openMonsterBattleInfoModal() {
    document.getElementById('monsterBattleInfoModal').style.display = 'flex';
}
function closeMonsterBattleInfoModal() {
    document.getElementById('monsterBattleInfoModal').style.display = 'none';
}

// useRevivalStone fonksiyonunu bununla deÄŸiÅŸtir
async function useRevivalStone() {
    if (isAdmin) return;

    const reviveBtn = document.getElementById('reviveBtn');
    reviveBtn.disabled = true;

    try {
        const userRef = db.ref(`users/${currentUser}`);
        const battleRef = db.ref('gameConfig/monsterBattle');

        const [userSnap, battleSnap] = await Promise.all([userRef.once('value'), battleRef.once('value')]);
        
        const userData = userSnap.val();
        const battleData = battleSnap.val();
        
        const playerBattleData = battleData?.damageLeaderboard?.[currentUser];

        if (!playerBattleData || playerBattleData.currentHP > 0) {
            throw new Error("CanÄ±n zaten dolu veya savaÅŸta deÄŸilsin.");
        }

        const revivalStones = userData.inventory?.revival_stone || 0;
        if (revivalStones < 1) {
            // GÃœNCELLEME BURADA
            displayMessageWithRedirect("Dirilmek iÃ§in Dirilme TaÅŸÄ±n yok!", "MaÄŸazaya Git", () => {
                storeFilter = { type: 'revival_stone' };
                showSection('store');
            });
            return; 
        }

        const stoneRef = userRef.child('inventory/revival_stone');
        const { committed } = await stoneRef.transaction(currentStones => {
            if ((currentStones || 0) > 0) {
                return currentStones - 1;
            }
            return;
        });
        
        if (!committed) {
            throw new Error("Dirilme taÅŸÄ± kullanÄ±lamadÄ±. Envanterin baÅŸka bir iÅŸlem tarafÄ±ndan gÃ¼ncellenmiÅŸ olabilir.");
        }
        
        const playerAvatarUrl = playerBattleData.lockedAvatarUrl || userData.selectedAvatar?.url || defaultAvatarUrl;
        const sanitizedPlayerAvatarId = sanitizeFirebaseKey(playerAvatarUrl);
        
        const globalBuffs = userData.globalPotionBuffs || {};
        const baseStats = avatarBaseStats[sanitizedPlayerAvatarId] || {};
        const playerMaxHP = (baseStats.hp || 1000) + (globalBuffs.hp || 0);

        await battleRef.child(`damageLeaderboard/${currentUser}/currentHP`).set(playerMaxHP);

        displayMessage("Dirilme TaÅŸÄ± kullanÄ±ldÄ± ve canÄ±n tamamen yenilendi. Tekrar savaÅŸa hazÄ±rsÄ±n!");

    } catch (error) {
        displayMessage(error.message);
    } finally {
        reviveBtn.disabled = false;
    }
}

/**
 * Adminin mevcut canavarÄ± oyundan kaldÄ±rmasÄ±nÄ± saÄŸlar.
 */
async function deleteCurrentMonster() {
    if (!isAdmin) return;
    const confirmed = await customConfirm("Mevcut canavarÄ± ve tÃ¼m savaÅŸ ilerlemesini kalÄ±cÄ± olarak silmek istediÄŸinizden emin misiniz?");
    if (confirmed) {
        await db.ref('gameConfig/monsterBattle').remove();
        displayMessage("Canavar baÅŸarÄ±yla kaldÄ±rÄ±ldÄ±.");
    }
}

function openMonsterInfoModal() {
    const monster = monsterBattleData.monsterDetails;
    if (!monster) return;

    document.getElementById('modalMonsterName').textContent = monster.name;
    const imgEl = document.getElementById('modalMonsterImage');
    if (imgEl && monster.imageUrl) {
        imgEl.src = monster.imageUrl;
        imgEl.style.display = 'block';
    } else if (imgEl) {
        imgEl.style.display = 'none';
    }
    
    const statsEl = document.getElementById('modalMonsterStats');
    statsEl.innerHTML = `
        <p>â¤ï¸ Can: <b class="text-white">${formatNumber(monster.maxHP)}</b></p>
        <p>âš”ï¸ Hasar: <b class="text-white">${formatNumber(monster.minDamage)} - ${formatNumber(monster.maxDamage)}</b></p>
        <p>ğŸ¯ Kritik Hasar: <b class="text-white">+%${(monster.critDamage || 10).toFixed(1)}</b></p>
        <p>ğŸ›¡ï¸ Savunma ÅansÄ±: <b class="text-white">%${(monster.defense || 0).toFixed(1)}</b></p>
        <p>ğŸ’¨ SÄ±yrÄ±lma ÅansÄ±: <b class="text-white">%${(monster.dodgeChance || 5).toFixed(1)}</b></p>
        <p>ğŸ“Œ Delici VuruÅŸ ÅansÄ±: <b class="text-white">%${(monster.pierceChance || 5).toFixed(1)}</b></p>
        <p>ğŸ’¥ Kritik VuruÅŸ ÅansÄ±: <b class="text-white">%${(monster.critChance || 5).toFixed(1)}</b></p>
    `;

    const killReward = monsterBattleData.rewards?.onKillLeader;
    const killRewardEl = document.getElementById('modalKillReward');
    if (killReward) {
        const prizeText = formatRewardText(killReward.type, killReward.value);
        killRewardEl.innerHTML = `Canavar yok edildiÄŸi zaman hasar tablosunda 1. sÄ±rada olan oyuncu <b class="text-green-400">${prizeText}</b> kazanÄ±r.`;
    } else {
        killRewardEl.textContent = 'Liderlik Ã¶dÃ¼lÃ¼ belirlenmemiÅŸ.';
    }

    const tiers = monsterBattleData.damageTiers || [];
    const tiersEl = document.getElementById('modalDamageTiers');
    if (tiers.length > 0) {
        tiersEl.innerHTML = '';
        tiers.sort((a,b) => a.minDamage - b.minDamage).forEach(tier => {
            const rewardTexts = tier.rewards.map(r => {
                const formattedText = formatRewardText(r.type, r.value);
                return `${formattedText} (%${r.chance})`;
            }).join(', ');
            
            tiersEl.innerHTML += `<div><b class="text-white">${formatNumber(tier.minDamage)}+ Hasar</b> vuranlar ÅŸu Ã¶dÃ¼llerden birini kazanma ÅŸansÄ± yakalar: <span class="text-cyan-300">${rewardTexts}</span></div>`;
        });
    } else {
        tiersEl.textContent = 'Bu canavar iÃ§in Ã¶zel hasar eÅŸiÄŸi Ã¶dÃ¼lÃ¼ ayarlanmamÄ±ÅŸ.';
    }

    document.getElementById('monsterInfoModal').style.display = 'flex';
}
      
/**
 * Canavar bilgi penceresini kapatÄ±r.
 */
function closeMonsterInfoModal() {
    document.getElementById('monsterInfoModal').style.display = 'none';
}

 /**
 * Firebase anahtarlarÄ±nda kullanÄ±lamayacak yasaklÄ± karakterleri temizler.
 * @param {string} key - Temizlenecek olan metin.
 * @returns {string} TemizlenmiÅŸ ve Firebase iÃ§in gÃ¼venli metin.
 */
function sanitizeFirebaseKey(key) {
    if (!key) return '';
    // Firebase'in yasakladÄ±ÄŸÄ± karakterleri (. # $ [ ] /) bulur ve kaldÄ±rÄ±r.
    // DEÄÄ°ÅÄ°KLÄ°K: ':' ve '/' karakterlerini de '_' ile deÄŸiÅŸtirerek URL'leri daha gÃ¼venli hale getiriyoruz.
    return key.replace(/[.#$[\]/]/g, '').replace(/:/g, '_');
}

function handleWeeklyPrizeTypeChange() {
    const prizeType = document.getElementById('weeklyPrizeType').value;
    const amountInput = document.getElementById('weeklyPrizeAmount');
    const usesInput = document.getElementById('weeklyPrizeMultiplierUses');
    const specialNameInput = document.getElementById('weeklyPrizeSpecialName');

    // Ã–nce tÃ¼m Ã¶zel alanlarÄ± varsayÄ±lan durumuna getir
    amountInput.classList.remove('hidden', 'col-span-2');
    usesInput.classList.add('hidden');
    specialNameInput.classList.add('hidden');

    if (prizeType === 'tempMultiplier') {
        amountInput.placeholder = 'Ã‡arpan DeÄŸeri (Ã¶rn: 2)';
        usesInput.classList.remove('hidden');
    } else if (prizeType === 'special') {
        // Ã–zel Ã¼rÃ¼n seÃ§ilirse miktar ve kullanÄ±m alanlarÄ±nÄ± gizle, isim alanÄ±nÄ± gÃ¶ster
        amountInput.classList.add('hidden');
        usesInput.classList.add('hidden');
        specialNameInput.classList.remove('hidden');
    } else {
        amountInput.placeholder = 'Miktar';
    }
}

      // BU YEPYENÄ° FONKSÄ°YONU SCRIPT BLOÄUNUZUN UYGUN BÄ°R YERÄ°NE EKLEYÄ°N

function customAlert(message) {
    return new Promise(resolve => {
        const alertBox = document.createElement('div');
        // Z-index'i yÃ¼ksek tutarak diÄŸer modallarÄ±n Ã¼zerinde gÃ¶rÃ¼nmesini saÄŸlÄ±yoruz.
        alertBox.className = 'fixed inset-0 bg-black bg-opacity-80 flex justify-center items-center z-[99999]';
        alertBox.innerHTML = `
          <div class="bg-gray-800 p-8 rounded-xl shadow-2xl border border-blue-500 w-11/12 max-w-md text-center relative">
            <p class="text-lg text-gray-300 mb-6">${message}</p>
            <button id="alertOkBtn" class="w-full py-3 bg-blue-700 hover:bg-blue-600 text-white font-bold rounded-lg">Tamam</button>
          </div>
        `;
        document.body.appendChild(alertBox);
        
        document.getElementById('alertOkBtn').onclick = (event) => { 
            event.preventDefault(); 
            alertBox.remove(); 
            resolve(true); // "Tamam" butonuna basÄ±ldÄ±ÄŸÄ±nda Promise'i Ã§Ã¶zerek beklemenin bitmesini saÄŸlÄ±yoruz.
        };
    });
}

async function convertWildcard() {
    if (isAdmin) return;

    const confirmed = await customConfirm("1 adet Joker Kart'Ä± 10 Kutu HakkÄ±'na dÃ¶nÃ¼ÅŸtÃ¼rmek istediÄŸinize emin misiniz? Bu iÅŸlem geri alÄ±namaz!");
    if (!confirmed) return;

    const userRef = db.ref(`users/${currentUser}`);

    try {
        const { committed, snapshot } = await userRef.transaction(userData => {
            if (userData && (userData.wildcards || 0) > 0) {
                userData.wildcards--;
                userData.kutuHakki = (userData.kutuHakki || 0) + 10;
                return userData;
            }
            return; 
        });

        if (committed) {
            displayMessage("BaÅŸarÄ±lÄ±! 1 Joker Kart, 10 Kutu HakkÄ±'na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼.");
            logActivity('wildcardConvertedToBoxRights', currentUser, {
                boxRights: 10,
                newBoxRights: snapshot.val().kutuHakki
            });
            if (currentActiveSection === 'cardCollection') {
                loadCollectionAlbum();
            }
        } else {
            throw new Error("DÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi baÅŸarÄ±sÄ±z oldu. Yeterli Joker KartÄ±nÄ±z olmayabilir.");
        }
    } catch (error) {
        displayMessage(error.message);
    }
}

      async function resetUser(username) {
    if (!isAdmin || !username) return;

    const confirmed = await customConfirm(
        `<b>${username}</b> adlÄ± kullanÄ±cÄ±yÄ± sÄ±fÄ±rlamak istediÄŸinize emin misiniz? Bu iÅŸlem, kullanÄ±cÄ±nÄ±n AvatarlarÄ±, Kasa PuanlarÄ± ve KalÄ±cÄ± Ä°ksir BonuslarÄ± DIÅINDAKÄ° tÃ¼m verilerini (puanlar, envanter, istatistikler, sÄ±ralamalar, kartlar vb.) kalÄ±cÄ± olarak silecektir!`
    );

    if (!confirmed) return;

    try {
        const userRef = db.ref(`users/${username}`);
        const userSnap = await userRef.once('value');
        if (!userSnap.exists()) {
            throw new Error("KullanÄ±cÄ± bulunamadÄ±.");
        }
        const userData = userSnap.val();

        // KORUNACAK VERÄ°LERÄ° YEDEKLE
        const preservedData = {
            kasaPuani: userData.kasaPuani || 0,
            avatars: userData.avatars || null,
            globalPotionBuffs: userData.globalPotionBuffs || null,
            password: userData.password,
            pin: userData.pin,
            approved: userData.approved,
            registeredAt: userData.registeredAt || new Date().toLocaleString()
        };

        // KULLANICIYI SÄ°LÄ°P KORUNAN VERÄ°LERLE YENÄ°DEN OLUÅTUR
        const updates = {};
        updates[`/users/${username}`] = preservedData;
        // GÃœNCELLENEN KISIM: Ä°lgili tÃ¼m liderlik tablolarÄ±ndan kullanÄ±cÄ±yÄ± temizle
        updates[`/clickCatchWeeklyScores/${username}`] = null;
        updates[`/gameConfig/monsterBattle/damageLeaderboard/${username}`] = null;
        
        await db.ref().update(updates);
        
        displayMessage(`${username} baÅŸarÄ±yla sÄ±fÄ±rlandÄ±. Kasa PuanÄ±, avatarlarÄ± ve iksir bonuslarÄ± korundu.`);
        closeUserManagementModal();
        
    } catch (error) {
        console.error("KullanÄ±cÄ± sÄ±fÄ±rlanÄ±rken hata oluÅŸtu:", error);
        displayMessage("KullanÄ±cÄ± sÄ±fÄ±rlanÄ±rken bir hata meydana geldi: " + error.message);
    }
}

// BU YEPYENÄ° FONKSÄ°YONU SCRIPT BLOÄUNUZA EKLEYÄ°N

async function resetUserPotionBonuses(username) {
    if (!isAdmin || !username) return;

    const confirmed = await customConfirm(
        `<b>${username}</b> adlÄ± kullanÄ±cÄ±nÄ±n maÄŸazadan aldÄ±ÄŸÄ± <b>tÃ¼m kalÄ±cÄ± iksir bonuslarÄ±nÄ±</b> sÄ±fÄ±rlamak istediÄŸinize emin misiniz? Bu iÅŸlem geri alÄ±namaz!`
    );

    if (!confirmed) return;

    try {
        const userRef = db.ref(`users/${username}`);
        
        // KullanÄ±cÄ±nÄ±n globalPotionBuffs anahtarÄ±nÄ± silerek tÃ¼m bonuslarÄ± sÄ±fÄ±rla
        await userRef.child('globalPotionBuffs').remove();
        
        displayMessage(`${username} adlÄ± kullanÄ±cÄ±nÄ±n tÃ¼m kalÄ±cÄ± iksir bonuslarÄ± baÅŸarÄ±yla sÄ±fÄ±rlandÄ±.`);
        
        // ArayÃ¼zÃ¼ anÄ±nda gÃ¼ncellemek iÃ§in yÃ¶netim modalÄ±nÄ± yeniden aÃ§
        openUserManagementModal(event, username);
        
    } catch (error) {
        console.error("Ä°ksir bonuslarÄ± sÄ±fÄ±rlanÄ±rken hata oluÅŸtu:", error);
        displayMessage("Bonuslar sÄ±fÄ±rlanÄ±rken bir hata meydana geldi: " + error.message);
    }
}

// BU YEPYENÄ° FONKSÄ°YONU SCRIPT BLOÄUNUZA EKLEYÄ°N

/**
 * Adminin, tÃ¼m kullanÄ±cÄ±larÄ±n kalÄ±cÄ± iksir bonuslarÄ±nÄ± tek seferde sÄ±fÄ±rlamasÄ±nÄ± saÄŸlar.
 */
async function resetAllPotionBonuses() {
    if (!isAdmin) return;

    // Bu, Ã§ok gÃ¼Ã§lÃ¼ bir iÅŸlem olduÄŸu iÃ§in net bir onay mesajÄ± gÃ¶steriyoruz.
    const confirmed = await customConfirm(
        "TÃœM kullanÄ±cÄ±larÄ±n sahip olduÄŸu KALICI iksir bonuslarÄ±nÄ± sÄ±fÄ±rlamak istediÄŸinize emin misiniz? Bu iÅŸlem geri alÄ±namaz!"
    );

    if (!confirmed) return;

    try {
        const usersRef = db.ref('users');
        const usersSnap = await usersRef.once('value');
        const usersData = usersSnap.val();

        // Tek seferde yapÄ±lacak tÃ¼m gÃ¼ncellemeleri bu objede toplayacaÄŸÄ±z.
        const updates = {};
        
        if (usersData) {
            for (const username in usersData) {
                // Sadece iksir bonusu olan kullanÄ±cÄ±lar iÃ§in silme iÅŸlemi hazÄ±rla
                if (usersData[username] && usersData[username].globalPotionBuffs) {
                    // globalPotionBuffs anahtarÄ±nÄ± null olarak ayarlamak, onu veritabanÄ±ndan siler.
                    updates[`/users/${username}/globalPotionBuffs`] = null;
                }
            }
        }

        // EÄŸer gÃ¼ncellenecek bir ÅŸey varsa (yani en az bir kullanÄ±cÄ±nÄ±n bonusu varsa)
        if (Object.keys(updates).length > 0) {
            await db.ref().update(updates);
            displayMessage("TÃ¼m kullanÄ±cÄ±larÄ±n kalÄ±cÄ± iksir bonuslarÄ± baÅŸarÄ±yla sÄ±fÄ±rlandÄ±.");
        } else {
            displayMessage("SÄ±fÄ±rlanacak iksir bonusuna sahip hiÃ§bir kullanÄ±cÄ± bulunamadÄ±.");
        }

    } catch (error) {
        console.error("Toplu iksir bonusu sÄ±fÄ±rlama hatasÄ±:", error);
        displayMessage("Ä°ÅŸlem sÄ±rasÄ±nda bir hata meydana geldi: " + error.message);
    }
}

// YENÄ° EKLENECEK KOD BAÅLANGICI

let potionCapsCache = {}; // Ä°ksir limitlerini Ã¶nbellekte tutmak iÃ§in

/**
 * Admin panelindeki iksir limiti ayarlarÄ±nÄ± veritabanÄ±ndan yÃ¼kler ve input'lara yazar.
 */
async function loadPotionCapsForAdmin() {
    if (!isAdmin) return;
    const capsRef = db.ref('gameConfig/potionCaps');
    const capsSnap = await capsRef.once('value');
    const caps = capsSnap.val() || {};

    document.getElementById('potionCapHp').value = caps.hp || '';
    document.getElementById('potionCapDamage').value = caps.damage || '';
    document.getElementById('potionCapDefense').value = caps.defense || '';
    document.getElementById('potionCapCritDamage').value = caps.critDamage || '';
    document.getElementById('potionCapDodge').value = caps.dodgeChance || '';
    document.getElementById('potionCapPierce').value = caps.pierceChance || '';
    document.getElementById('potionCapCrit').value = caps.critChance || '';
}

/**
 * Admin panelindeki iksir limiti ayarlarÄ±nÄ± kaydeder.
 */
async function savePotionCaps() {
    if (!isAdmin) return;
    const caps = {
        hp: parseInt(document.getElementById('potionCapHp').value) || null,
        damage: parseInt(document.getElementById('potionCapDamage').value) || null,
        defense: parseInt(document.getElementById('potionCapDefense').value) || null,
        critDamage: parseFloat(document.getElementById('potionCapCritDamage').value) || null,
        dodgeChance: parseFloat(document.getElementById('potionCapDodge').value) || null,
        pierceChance: parseFloat(document.getElementById('potionCapPierce').value) || null,
        critChance: parseFloat(document.getElementById('potionCapCrit').value) || null,
    };
    await db.ref('gameConfig/potionCaps').set(caps);
    displayMessage("Ä°ksir bonus limitleri baÅŸarÄ±yla kaydedildi.");
}

/**
 * Bir kullanÄ±cÄ±nÄ±n belirli bir iksiri alÄ±p alamayacaÄŸÄ±nÄ± ve ne kadar alabileceÄŸini kontrol eder.
 * @param {object} userData KullanÄ±cÄ±nÄ±n tam verisi.
 * @param {string} potionType 'health_potion', 'damage_potion' gibi iksir tipi.
 * @param {number} amountToAdd Eklenmek istenen miktar.
 * @returns {object} { canAdd: boolean, amount: number, isCapped: boolean }
 */
function checkPotionCap(userData, potionType, amountToAdd) {
    const statKeyMap = { 
        health_potion: 'hp', damage_potion: 'damage', defense_potion: 'defense', 
        crit_potion: 'critChance', crit_damage_potion: 'critDamage', 
        dodge_potion: 'dodgeChance', pierce_potion: 'pierceChance' 
    };
    const statKey = statKeyMap[potionType];
    if (!statKey) return { canAdd: true, amount: amountToAdd, isCapped: false }; // Bilinmeyen iksir tÃ¼rÃ¼, limitleme

    const cap = potionCapsCache[statKey];
    // EÄŸer bu stat iÃ§in bir limit belirlenmemiÅŸse, tam miktarÄ± eklemesine izin ver
    if (cap === undefined || cap === null) {
        return { canAdd: true, amount: amountToAdd, isCapped: false };
    }

    const currentBonus = userData.globalPotionBuffs?.[statKey] || 0;
    
    // KullanÄ±cÄ± zaten limitte veya limiti geÃ§miÅŸse, hiÃ§bir ÅŸey ekleyemez
    if (currentBonus >= cap) {
        return { canAdd: false, amount: 0, isCapped: true };
    }

    const potentialTotal = currentBonus + amountToAdd;
    // EÄŸer eklenecek miktar limiti aÅŸmÄ±yorsa, tam miktarÄ± eklemesine izin ver
    if (potentialTotal <= cap) {
        return { canAdd: true, amount: amountToAdd, isCapped: false };
    } 
    // EÄŸer eklenecek miktar limiti aÅŸÄ±yorsa, sadece limite ulaÅŸacak kadarÄ±nÄ± eklemesine izin ver
    else {
        const amountCanAdd = cap - currentBonus;
        return { canAdd: true, amount: amountCanAdd, isCapped: true };
    }
}

// useHealthRegenPotion fonksiyonunu bununla deÄŸiÅŸtir
async function useHealthRegenPotion() {
    const selector = document.getElementById('regenPotionSelector');
    const useButton = document.getElementById('useRegenPotionBtn');

    if (useButton) useButton.disabled = true;

    try {
        const userRef = db.ref(`users/${currentUser}`);
        const battleRef = db.ref('gameConfig/monsterBattle');

        const [userSnap, battleSnap] = await Promise.all([userRef.once('value'), battleRef.once('value')]);
        
        const userData = userSnap.val();
        const battleData = battleSnap.val();
        const playerBattleData = battleData?.damageLeaderboard?.[currentUser];

        const regenPotions = userData.inventory?.health_regen_potion || {};
        const hasPotions = Object.values(regenPotions).some(count => count > 0);
        const playerCurrentHP = playerBattleData?.currentHP || 0;
        const isPlayerDead = playerCurrentHP <= 0;
        
        const playerAvatarUrl = playerBattleData?.lockedAvatarUrl || userData.selectedAvatar?.url || defaultAvatarUrl;
        const sanitizedPlayerAvatarId = sanitizeFirebaseKey(playerAvatarUrl);
        const playerMaxHP = (avatarBaseStats[sanitizedPlayerAvatarId]?.hp || 1000) + (userData.globalPotionBuffs?.hp || 0);
        const isPlayerFullHealth = playerCurrentHP >= playerMaxHP;
        const selectedValue = selector.value;

        if (isPlayerDead) {
            throw new Error("MaÄŸlup durumdayken can iksiri kullanamazsÄ±n!");
        }
        if (!hasPotions) {
            // GÃœNCELLEME BURADA
            displayMessageWithRedirect("Mevcut can yenileme iksirin yok.", "MaÄŸazaya Git", () => {
                storeFilter = { type: 'health_regen_potion' };
                showSection('store');
            });
            throw new Error("Ä°ÅŸlem iptal edildi.");
        }
        if (isPlayerFullHealth) {
            throw new Error("CanÄ±n zaten dolu olduÄŸu iÃ§in iksir kullanamazsÄ±n.");
        }
        if (!selectedValue) {
            throw new Error("LÃ¼tfen kullanmak iÃ§in bir iksir seÃ§.");
        }

        const percentage = parseInt(selectedValue);
        const potionCount = userData.inventory?.health_regen_potion?.[percentage] || 0;
        if (potionCount < 1) {
            throw new Error(`Kullanmak istediÄŸin %${percentage} iksirinden kalmamÄ±ÅŸ.`);
        }

        const healingAmount = Math.floor(playerMaxHP * (percentage / 100));
        const newHP = Math.min(playerMaxHP, playerCurrentHP + healingAmount);
        const actualHeal = newHP - playerCurrentHP;

        const updates = {};
        updates[`/users/${currentUser}/inventory/health_regen_potion/${percentage}`] = potionCount - 1;
        updates[`/gameConfig/monsterBattle/damageLeaderboard/${currentUser}/currentHP`] = newHP;
        
        await db.ref().update(updates);

        displayMessage(`BaÅŸarÄ±lÄ±! ${actualHeal} can yeniledin.`);
        
        logActivity('useRegenPotion', currentUser, { 
            percentage: percentage, 
            healed: actualHeal,
            newHP: newHP,
            playerMaxHP: playerMaxHP
        });

    } catch (error) {
        if (error.message !== "Ä°ÅŸlem iptal edildi.") {
            displayMessage(error.message);
        }
    } finally {
        if (useButton) useButton.disabled = false;
        handlePotionSelectionChange();
    }
}

      // --- YENÄ° VE Ã‡ALIÅAN FONKSÄ°YON ---
async function saveAvatarStats() {
    if (!isAdmin) return;

    const confirmed = await customConfirm("TÃ¼m avatarlarÄ±n temel istatistiklerini kaydetmek istediÄŸinize emin misiniz? Bu iÅŸlem, tÃ¼m avatarlarÄ±n Ã¶zelliklerini gÃ¼ncelleyecektir.");
    if (!confirmed) return;

    const updates = {};
    let hasError = false;

    document.querySelectorAll('#avatarStatEditor .p-3').forEach(row => {
        if (hasError) return;
        const avatarId = row.dataset.avatarId;
        if (!avatarId) return;

        // SayÄ±sal deÄŸerleri alÄ±rken ondalÄ±k sayÄ±lar iÃ§in virgÃ¼lÃ¼ noktaya Ã§eviriyoruz
        const hp = parseInt(row.querySelector('.stat-hp').value);
        const minDamage = parseInt(row.querySelector('.stat-min-damage').value);
        const maxDamage = parseInt(row.querySelector('.stat-max-damage').value);
        const defense = parseInt(row.querySelector('.stat-defense').value);
        const critDamage = parseFloat(String(row.querySelector('.stat-crit-damage').value).replace(',', '.'));
        const dodgeChance = parseFloat(String(row.querySelector('.stat-dodge').value).replace(',', '.'));
        const pierceChance = parseFloat(String(row.querySelector('.stat-pierce').value).replace(',', '.'));
        const critChance = parseFloat(String(row.querySelector('.stat-crit').value).replace(',', '.'));
        
        // EÄŸer bir alanda geÃ§ersiz bir deÄŸer varsa (NaN), kullanÄ±cÄ±yÄ± uyar ve iÅŸlemi durdur.
        if (isNaN(hp) || isNaN(minDamage) || isNaN(maxDamage) || isNaN(defense) || isNaN(critDamage) || isNaN(dodgeChance) || isNaN(pierceChance) || isNaN(critChance)) {
            displayMessage("LÃ¼tfen tÃ¼m alanlarÄ± geÃ§erli sayÄ±larla doldurun. OndalÄ±klÄ± sayÄ±lar iÃ§in nokta (.) kullanÄ±n.");
            hasError = true;
            return;
        }
        
        updates[`/gameConfig/avatarBaseStats/${avatarId}`] = {
            hp: hp,
            minDamage: minDamage,
            maxDamage: maxDamage,
            defense: defense,
            critDamage: critDamage,
            dodgeChance: dodgeChance,
            pierceChance: pierceChance,
            critChance: critChance
        };
    });

    if (hasError) return;

    await db.ref().update(updates);
    displayMessage("TÃ¼m avatarlarÄ±n temel istatistikleri baÅŸarÄ±yla kaydedildi!");
}

// BU KOD BLOÄUNU let currentActiveSection = 'game'; SATIRININ ALTINA EKLE

let storeFilter = null; // MaÄŸazayÄ± filtrelemek iÃ§in kullanÄ±lacak global deÄŸiÅŸken

// Canavar sayfasÄ±ndan maÄŸazaya yÃ¶nlendirir ve iksir filtresini aktif eder
function goToMonsterStore() {
    // Filtreyi 'canavar savaÅŸÄ±' olarak ayarla
    storeFilter = { type: 'monster_battle' };
    // MaÄŸaza bÃ¶lÃ¼mÃ¼nÃ¼ gÃ¶ster
    showSection('store');
}

// MEVCUT listenForPersistentNotifications FONKSÄ°YONUNU SÄ°LÄ°P BUNU YAPIÅTIR

function listenForPersistentNotifications() {
    if (isAdmin) return;
    const ref = db.ref(`users/${currentUser}/persistentNotifications`);
    
    const callback = (snap) => {
        const notifId = snap.key;
        const notification = snap.val();
        
        if (notification && notification.type) {
            // YENÄ° EKLENEN KISIM: 'collectionCompleted' tipini yakala
            switch(notification.type) {
                case 'collectionCompleted':
                    showCollectionCompleteModal(notification);
                    break;
                case 'tradesCancelled':
                    displayMessage(notification.message);
                    break;
            }
            // Bildirimi gÃ¶sterdikten sonra veritabanÄ±ndan sil
            snap.ref.remove();
        }
    };
    
    if (activeListeners.persistentNotifs) {
        activeListeners.persistentNotifs.ref.off('child_added', activeListeners.persistentNotifs.callback);
    }
    activeListeners.persistentNotifs = { ref, event: 'child_added', callback };
    ref.on('child_added', callback);
}

// Koleksiyon tamamlama penceresini gÃ¶sterir
function showCollectionCompleteModal(notificationData) {
    document.getElementById('collectionCompleteTitle').innerHTML = notificationData.title;
    document.getElementById('collectionCompleteMessage').innerHTML = notificationData.message;
    document.getElementById('collectionCompleteModal').style.display = 'flex';
}

// Koleksiyon tamamlama penceresini kapatÄ±r
function closeCollectionCompleteModal() {
    document.getElementById('collectionCompleteModal').style.display = 'none';
}

// Koleksiyon tamamlama penceresini kapatÄ±r
function closeCollectionCompleteModal() {
    document.getElementById('collectionCompleteModal').style.display = 'none';
}

// --- YENÄ° EKLENECEK KOD: GLOBAL Ä°NTERNET BAÄLANTI KONTROLÃœ ---

const connectionStatusOverlay = document.getElementById('connectionStatusOverlay');

// BaÄŸlantÄ± koptuÄŸunda Ã§alÄ±ÅŸacak fonksiyon
function handleOffline() {
    if (connectionStatusOverlay) {
        connectionStatusOverlay.style.display = 'flex';
    }
}

// BaÄŸlantÄ± geri geldiÄŸinde Ã§alÄ±ÅŸacak fonksiyon
function handleOnline() {
    if (connectionStatusOverlay) {
        connectionStatusOverlay.style.display = 'none';
    }
}

// TarayÄ±cÄ±nÄ±n online/offline olaylarÄ±nÄ± dinle
window.addEventListener('offline', handleOffline);
window.addEventListener('online', handleOnline);

// Sayfa ilk yÃ¼klendiÄŸinde durumu kontrol et
// Bu, sayfa aÃ§Ä±ldÄ±ÄŸÄ±nda zaten internet yoksa uyarÄ±yÄ± gÃ¶stermek iÃ§in gereklidir.
document.addEventListener('DOMContentLoaded', () => {
    if (!navigator.onLine) {
        handleOffline();
    }
});

/**
 * Sohbet panelinin gÃ¶rÃ¼nÃ¼rlÃ¼ÄŸÃ¼nÃ¼ aÃ§ar veya kapatÄ±r. (GÃœNCELLENDÄ°)
 */
function toggleChat() {
    const panel = document.getElementById('chatPanel');
    const btn = document.getElementById('chatToggleBtn'); // Butonu da seÃ§iyoruz
    const dot = document.getElementById('chatNotificationDot');
    
    panel.classList.toggle('open');
    btn.classList.toggle('open'); // Butona da 'open' sÄ±nÄ±fÄ±nÄ± ekleyip/kaldÄ±rÄ±yoruz
    
    // Panel aÃ§Ä±ldÄ±ÄŸÄ±nda bildirim noktasÄ±nÄ± gizle
    if (panel.classList.contains('open')) {
        dot.classList.add('hidden');
    }
}

// sendMessage FONKSÄ°YONUNU BUL VE BUNUNLA DEÄÄ°ÅTÄ°R
async function sendMessage() {
    const now = getSyncedTime();
    if (chatSettings.slowModeSeconds > 0 && now < lastMessageTimestamp + (chatSettings.slowModeSeconds * 1000)) {
        const remaining = Math.ceil(((lastMessageTimestamp + (chatSettings.slowModeSeconds * 1000)) - now) / 1000);
        displayMessage(`YavaÅŸ mod aktif. Mesaj gÃ¶ndermek iÃ§in ${remaining} saniye beklemelisin.`);
        return;
    }

    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (text === '') return;

    const userRef = db.ref(`users/${currentUser}`);
    const userSnap = await userRef.once('value');
    const userData = userSnap.val();

    if (!userData && !isAdmin) return;

    if (!isAdmin && userData.chatMutedUntil && userData.chatMutedUntil > now) {
        const remainingMinutes = Math.ceil((userData.chatMutedUntil - now) / 60000);
        displayMessage(`Sohbetten uzaklaÅŸtÄ±rÄ±ldÄ±n. Kalan sÃ¼re: ${remainingMinutes} dakika.`);
        return;
    }

    const messageData = {
        username: currentUser,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        isDeleted: false
    };

    db.ref('chat/messages').push(messageData);
    input.value = '';
    lastMessageTimestamp = now;
}

/**
 * Adminin bir sohbet mesajÄ±nÄ± silmesini saÄŸlar.
 */
async function deleteChatMessage(messageId) {
    if (!isAdmin) return;
    const confirmed = await customConfirm("Bu sohbet mesajÄ±nÄ± silmek istediÄŸinize emin misiniz?");
    if (confirmed) {
        await db.ref(`chat/messages/${messageId}`).remove();
    }
}

// listenForChatMessages FONKSÄ°YONUNU BUL VE BUNUNLA DEÄÄ°ÅTÄ°R
function listenForChatMessages() {
    const messagesContainer = document.getElementById('chatMessages');
    const chatRef = db.ref('chat/messages').limitToLast(50);

    if (activeListeners.chat) {
        activeListeners.chat.ref.off('value', activeListeners.chat.callback);
    }

    const callback = async (snap) => {
        messagesContainer.innerHTML = '';
        const messages = [];
        
        snap.forEach(childSnap => {
            messages.push({ id: childSnap.key, ...childSnap.val() });
        });

        // Verimlilik iÃ§in tÃ¼m kullanÄ±cÄ±larÄ±n avatar bilgilerini tek seferde Ã§ekelim
        const usernamesInChat = [...new Set(messages.map(m => m.username))];
        const avatarPromises = usernamesInChat.map(username => 
            db.ref(`users/${username}/selectedAvatar/url`).once('value')
        );
        const avatarSnapshots = await Promise.all(avatarPromises);
        const avatarCache = {};
        avatarSnapshots.forEach((avatarSnap, index) => {
            const username = usernamesInChat[index];
            avatarCache[username] = avatarSnap.val() || defaultAvatarUrl;
        });
        // Admin avatarÄ±nÄ± da ekle
        avatarCache['WeizendTv'] = 'https://i.hizliresim.com/mtwdr1x.png';

        messages.reverse().forEach(message => {
            const messageEl = document.createElement('div');
            messageEl.className = 'chat-message';
            if (message.username === currentUser) {
                messageEl.classList.add('current-user');
            }

            const adminControls = (isAdmin && message.username !== currentUser) ? `
                <button class="delete-msg-btn" onclick="openAdminChatActionModal('${message.id}', '${message.username}')" title="Mesaj Eylemleri">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" /></svg>
                </button>` : '';
                
            let messageBodyHtml = '';
            let messageBodyClass = 'message-body';

            if (message.isDeleted) {
                if (message.deletedInfo && message.deletedInfo.reason === 'muted') {
                    messageBodyHtml = `[Mesaj silindi - KullanÄ±cÄ± ${message.deletedInfo.duration} dakika uzaklaÅŸtÄ±rÄ±ldÄ±]`;
                } else {
                    messageBodyHtml = '[Mesaj Admin TarafÄ±ndan Silindi]';
                }
                messageBodyClass += ' deleted-message-body';
            } else {
                const safeText = message.text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                messageBodyHtml = safeText.replace(/@(\w+)/g, (match, username) => {
                    return `<span class="user-mention" onclick="openPublicUserDetailModal('${username}')">${match}</span>`;
                });
            }

            // AvatarÄ± Ã¶nbellekten al
            const finalAvatarUrl = avatarCache[message.username];

            messageEl.innerHTML = `
                <img src="${finalAvatarUrl}" class="avatar" onclick="openAvatarStatsModal('${message.username}')">
                <div class="message-content">
                    <div class="message-header">
                        <span class="username" onclick="openPublicUserDetailModal('${message.username}')">${message.username}</span>
                        <span class="timestamp">${new Date(message.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                        ${adminControls}
                    </div>
                    <div class="${messageBodyClass}">${messageBodyHtml}</div>
                </div>
            `;
            messagesContainer.appendChild(messageEl);
        });

        const panel = document.getElementById('chatPanel');
        const lastMessage = messages[0];
        if (lastMessage && !panel.classList.contains('open') && lastMessage.username !== currentUser) {
            document.getElementById('chatNotificationDot').classList.remove('hidden');
        }
    };
    
    activeListeners.chat = { ref: chatRef, event: 'value', callback };
    chatRef.on('value', callback);

    document.getElementById('chatInput').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    document.getElementById('chatInput').addEventListener('input', handleChatInput);
}

/**
 * Admin iÃ§in 'MesajÄ± Sil / KullanÄ±cÄ±yÄ± UzaklaÅŸtÄ±r' penceresini aÃ§ar.
 */
function openAdminChatActionModal(messageId, username) {
    chatMuteTarget = { messageId, username }; // Hedef bilgileri global deÄŸiÅŸkene ata
    document.getElementById('adminActionTitle').textContent = `${username} | Eylem SeÃ§`;
    document.getElementById('adminDeleteMessageBtn').onclick = () => confirmDeleteMessage(messageId);
    document.getElementById('adminMuteUserBtn').onclick = () => openMuteUserModal(username);
    document.getElementById('adminChatActionModal').style.display = 'flex';
}

function closeAdminChatActionModal() {
    document.getElementById('adminChatActionModal').style.display = 'none';
}

/**
 * Tek bir sohbet mesajÄ±nÄ± 'silindi' olarak iÅŸaretler.
 */
async function confirmDeleteMessage(messageId) {
    await db.ref(`chat/messages/${messageId}`).update({ isDeleted: true });
    displayMessage("Mesaj baÅŸarÄ±yla silindi.");
    closeAdminChatActionModal();
    // ArayÃ¼zÃ¼n gÃ¼ncellenmesi iÃ§in sohbet dinleyicisini yeniden baÅŸlatÄ±yoruz.
    listenForChatMessages(); 
}

/**
 * KullanÄ±cÄ±yÄ± uzaklaÅŸtÄ±rmak iÃ§in sÃ¼re girme penceresini aÃ§ar.
 */
function openMuteUserModal(username) {
    closeAdminChatActionModal(); // Ã–nceki pencereyi kapat
    document.getElementById('muteUserTitle').textContent = `${username} AdlÄ± KullanÄ±cÄ±yÄ± UzaklaÅŸtÄ±r`;
    document.getElementById('muteUserModal').style.display = 'flex';
}

function closeMuteUserModal() {
    document.getElementById('muteUserModal').style.display = 'none';
    chatMuteTarget = {}; // Hedefi temizle
}

async function confirmMuteUser() {
    const durationMinutes = parseInt(document.getElementById('muteDurationInput').value);
    const usernameToMute = chatMuteTarget.username;

    if (isNaN(durationMinutes) || durationMinutes <= 0) {
        displayMessage("LÃ¼tfen geÃ§erli bir sÃ¼re girin.");
        return;
    }

    const muteUntilTimestamp = getSyncedTime() + (durationMinutes * 60 * 1000);
    
    await db.ref(`users/${usernameToMute}`).update({ chatMutedUntil: muteUntilTimestamp });

    const messagesRef = db.ref('chat/messages');
    const userMessagesSnap = await messagesRef.orderByChild('username').equalTo(usernameToMute).once('value');
    
    if (userMessagesSnap.exists()) {
        const updates = {};
        userMessagesSnap.forEach(childSnap => {
            // YENÄ°: SÄ°LÄ°NME BÄ°LGÄ°SÄ°NÄ° DETAYLI OLARAK KAYDET
            updates[`/chat/messages/${childSnap.key}/isDeleted`] = true;
            updates[`/chat/messages/${childSnap.key}/deletedInfo`] = {
                reason: 'muted',
                duration: durationMinutes
            };
        });
        await db.ref().update(updates);
    }
    
    displayMessage(`${usernameToMute} adlÄ± kullanÄ±cÄ± ${durationMinutes} dakika boyunca sohbetten uzaklaÅŸtÄ±rÄ±ldÄ± ve tÃ¼m mesajlarÄ± silindi.`);
    closeMuteUserModal();
    // ArayÃ¼zÃ¼n gÃ¼ncellenmesi iÃ§in sohbet dinleyicisini yeniden baÅŸlatmÄ±yoruz, 'value' listener bunu otomatik yapacak.
}

/**
 * YENÄ°: Adminin tÃ¼m sohbet geÃ§miÅŸini temizlemesini saÄŸlar.
 */
async function clearChatHistory() {
    if (!isAdmin) return;
    const confirmed = await customConfirm("TÃ¼m sohbet geÃ§miÅŸini kalÄ±cÄ± olarak silmek istediÄŸinizden emin misiniz? Bu iÅŸlem geri alÄ±namaz!");
    if (confirmed) {
        await db.ref('chat/messages').remove();
        displayMessage("Sohbet geÃ§miÅŸi baÅŸarÄ±yla temizlendi.");
        // 'value' listener sayesinde arayÃ¼z anÄ±nda gÃ¼ncellenecek.
    }
}

// YENÄ°: YavaÅŸ mod ayarlarÄ±nÄ± Firebase'den dinler
function listenForChatSettings() {
    const ref = db.ref('gameConfig/chat');
    const callback = (snap) => {
        chatSettings = snap.val() || { slowModeSeconds: 3 };
        // Admin paneli aÃ§Ä±ksa input'u gÃ¼ncelle
        if (adminPanelModal.style.display === 'flex') {
            document.getElementById('slowModeInput').value = chatSettings.slowModeSeconds || '';
        }
    };
    if (activeListeners.chatSettings) {
        ref.off('value', activeListeners.chatSettings.callback);
    }
    activeListeners.chatSettings = { ref, event: 'value', callback };
    ref.on('value', callback);
}

// YENÄ°: Adminin yavaÅŸ mod ayarlarÄ±nÄ± kaydetmesini saÄŸlar
async function saveSlowModeSettings() {
    if (!isAdmin) return;
    const seconds = parseInt(document.getElementById('slowModeInput').value) || 0;
    if (seconds < 0) {
        displayMessage("Saniye 0'dan kÃ¼Ã§Ã¼k olamaz.");
        return;
    }
    await db.ref('gameConfig/chat/slowModeSeconds').set(seconds);
    displayMessage(`Sohbet yavaÅŸ modu ${seconds > 0 ? seconds + ' saniye' : 'kapatÄ±ldÄ±'} olarak ayarlandÄ±.`);
}

// YENÄ°: Son Eylemler panelindeki bir aktiviteyi sohbette paylaÅŸÄ±r
async function shareActivityToChat(buttonElement) {
    const activityText = buttonElement.dataset.activityText;
    if (!activityText) return;

    const confirmed = await customConfirm(`Bu eylemi sohbette paylaÅŸmak istediÄŸine emin misin?<br><br><small class="text-gray-400">"${activityText}"</small>`);
    if (confirmed) {
        const userSnap = await db.ref(`users/${currentUser}`).once('value');
        const userData = userSnap.val();
        const avatarUrl = userData.selectedAvatar ? userData.selectedAvatar.url : defaultAvatarUrl;

        const messageData = {
            username: currentUser,
            text: activityText, // Eylem metnini doÄŸrudan kullan
            avatarUrl: avatarUrl,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isDeleted: false
        };

        db.ref('chat/messages').push(messageData);
        displayTemporaryNotification("Eylem sohbette paylaÅŸÄ±ldÄ±!", 'bg-green-600');
    }
}

// =======================================================
// YENÄ° Ã–ZELLÄ°K: AVATAR KODEKSÄ° SÄ°STEMÄ°
// =======================================================

let avatarCodexCache = {}; // Kodeks bilgilerini (nasÄ±l elde edilir vb.) Ã¶nbellekte tutar

// ESKÄ° openAvatarCodexModal FONKSÄ°YONUNU BUNUNLA DEÄÄ°ÅTÄ°R
async function openAvatarCodexModal() {
    const modal = document.getElementById('avatarCodexModal');
    const grid = document.getElementById('avatarCodexGrid');

    // --- YENÄ° EKLENEN KISIM BAÅLANGICI ---
    // EÄŸer kullanÄ±cÄ± admin ise, yÃ¶netim panelini aÃ§ma butonunu gÃ¶rÃ¼nÃ¼r yap.
    if (isAdmin) {
        document.getElementById('codexAdminBtn').classList.remove('hidden');
    } else {
        document.getElementById('codexAdminBtn').classList.add('hidden');
    }
    // --- YENÄ° EKLENEN KISIM SONU ---

    grid.innerHTML = '<p class="text-center col-span-full text-gray-400">Avatarlar yÃ¼kleniyor...</p>';
    modal.style.display = 'flex';

    try {
        const [codexSnap, statsSnap] = await Promise.all([
            db.ref('gameConfig/avatarCodex').once('value'),
            db.ref('gameConfig/avatarBaseStats').once('value')
        ]);

        const codexData = codexSnap.val() || {};
        avatarCodexCache = codexData; // Cache'i gÃ¼ncelle
        const statsData = statsSnap.val() || {};

        if (Object.keys(codexData).length === 0) {
            grid.innerHTML = '<p class="text-center col-span-full">HenÃ¼z kodekse eklenmiÅŸ bir avatar bulunmuyor.</p>';
            return;
        }

        grid.innerHTML = '';

        const sortedAvatars = Object.entries(codexData).sort((a, b) => (a[1].order || 0) - (b[1].order || 0));

        for (const [sanitizedId, avatarInfo] of sortedAvatars) {
            const avatarCard = document.createElement('div');
            avatarCard.className = 'relative p-2 rounded-lg cursor-pointer transition-transform hover:scale-105 bg-gray-800';
            // DeÄŸiÅŸecek satÄ±r:
avatarCard.onclick = () => showAvatarDetails(sanitizedId, true);

            avatarCard.innerHTML = `
                <img src="${avatarInfo.imageUrl}" alt="${avatarInfo.name}" class="w-full h-auto rounded-md object-cover aspect-square">
                <p class="text-xs mt-2 text-white font-bold truncate">${avatarInfo.name}</p>
                <div class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                    <span class="text-white text-xs font-bold">Detaylar</span>
                </div>
            `;
            grid.appendChild(avatarCard);
        }

    } catch (error) {
        console.error("Avatar Kodeksi yÃ¼klenirken hata:", error);
        grid.innerHTML = '<p class="text-center col-span-full text-red-500">Avatarlar yÃ¼klenemedi.</p>';
    }
}

/**
 * Avatar Kodeksi ana penceresini kapatÄ±r.
 */
function closeAvatarCodexModal() {
    document.getElementById('avatarCodexModal').style.display = 'none';
}

// ESKÄ° removeAvatarFromCodex FONKSÄ°YONUNU BUNUNLA DEÄÄ°ÅTÄ°R
async function removeAvatarFromCodex(sanitizedId) {
    if (!isAdmin) return;

    const confirmed = await customConfirm(
        "Bu avatarÄ± Kodeks'ten ve istatistiklerinden kalÄ±cÄ± olarak kaldÄ±rmak istediÄŸinize emin misiniz? <br><br><small>Bu iÅŸlem, avatara sahip olan kullanÄ±cÄ±lardan avatarÄ± SÄ°LMEZ, sadece listelerden kaldÄ±rÄ±r.</small>"
    );

    if (confirmed) {
        try {
            const updates = {};
            updates[`/gameConfig/avatarCodex/${sanitizedId}`] = null;
            updates[`/gameConfig/avatarBaseStats/${sanitizedId}`] = null;

            await db.ref().update(updates);

            displayMessage("Avatar Kodeks'ten ve istatistiklerden baÅŸarÄ±yla kaldÄ±rÄ±ldÄ±.");

            // Admin panelini yeniden yÃ¼kle
            openAdminAvatarCodexModal();

        } catch (error) {
            console.error("Avatar kaldÄ±rÄ±lÄ±rken hata oluÅŸtu:", error);
            displayMessage("Avatar kaldÄ±rÄ±lÄ±rken bir hata meydana geldi.");
        }
    }
}

// YENÄ° KODU YAPIÅTIR â–¼
/**
 * SeÃ§ilen avatarÄ±n detay penceresini aÃ§ar ve bilgileri doldurur.
 * @param {string} sanitizedId - AvatarÄ±n temizlenmiÅŸ ID'si.
 * @param {boolean} showObtainMethod - "NasÄ±l Elde Edilir?" bilgisinin gÃ¶sterilip gÃ¶sterilmeyeceÄŸi.
 */
function showAvatarDetails(sanitizedId, showObtainMethod = true) {
    const avatarInfo = avatarCodexCache[sanitizedId];
    const avatarStats = avatarBaseStats[sanitizedId] || {};

    if (!avatarInfo) return;

    document.getElementById('detailAvatarImage').src = avatarInfo.imageUrl;
    document.getElementById('detailAvatarName').textContent = avatarInfo.name;
    
    // --- GÃœNCELLEME BURADA ---
    const obtainMethodContainer = document.getElementById('detailAvatarObtainMethod').parentElement;
    if (showObtainMethod) {
        document.getElementById('detailAvatarObtainMethod').textContent = avatarInfo.obtainMethod || 'HenÃ¼z bir aÃ§Ä±klama eklenmemiÅŸ.';
        obtainMethodContainer.style.display = 'block';
    } else {
        obtainMethodContainer.style.display = 'none'; // "NasÄ±l Elde Edilir?" bÃ¶lÃ¼mÃ¼nÃ¼ gizle
    }
    // --- GÃœNCELLEME SONU ---

    const statsEl = document.getElementById('detailAvatarStats');
    statsEl.innerHTML = `
        <p>â¤ï¸ Can: <b class="text-white">${formatNumber(avatarStats.hp || 1000)}</b></p>
        <p>âš”ï¸ Hasar: <b class="text-white">${formatNumber(avatarStats.minDamage || 50)} - ${formatNumber(avatarStats.maxDamage || 100)}</b></p>
        <p>ğŸ¯ Kritik Hasar: <b class="text-white">+%${(avatarStats.critDamage || 10).toFixed(1)}</b></p>
        <p>ğŸ›¡ï¸ Savunma: <b class="text-white">%${(avatarStats.defense || 0).toFixed(1)}</b></p>
        <p>ğŸ’¨ SÄ±yrÄ±lma: <b class="text-white">%${(avatarStats.dodgeChance || 5).toFixed(1)}</b></p>
        <p>ğŸ“Œ Delici VuruÅŸ: <b class="text-white">%${(avatarStats.pierceChance || 5).toFixed(1)}</b></p>
        <p>ğŸ’¥ Kritik ÅansÄ±: <b class="text-white">%${(avatarStats.critChance || 5).toFixed(1)}</b></p>
    `;

    document.getElementById('avatarDetailModal').style.display = 'flex';
}

/**
 * Avatar detay penceresini kapatÄ±r.
 */
function closeAvatarDetailModal() {
    document.getElementById('avatarDetailModal').style.display = 'none';
}

// =======================================================
// YENÄ°: GÃœNCELLENMÄ°Å AVATAR KODEKSÄ° ADMÄ°N SÄ°STEMÄ°
// =======================================================

let editingAvatarData = null; // Hangi avatarÄ±n dÃ¼zenlendiÄŸini tutar

// MEVCUT openAdminAvatarCodexModal FONKSÄ°YONUNU SÄ°LÄ°P BUNU YAPIÅTIR
async function openAdminAvatarCodexModal() {
    if (!isAdmin) return;
    const listEl = document.getElementById('adminCodexList');
    listEl.innerHTML = '<p class="text-gray-400 text-center">Avatarlar taranÄ±yor ve listeleniyor...</p>';
    document.getElementById('adminAvatarCodexModal').style.display = 'flex';

    // Ã–nceki dinleyiciyi temizle ki tekrar tekrar eklenmesin
    if (activeListeners.adminCodex && activeListeners.adminCodex.ref) {
        activeListeners.adminCodex.ref.off('value', activeListeners.adminCodex.callback);
    }

    const ref = db.ref('gameConfig/avatarCodex');
    const callback = (codexSnap) => {
        const codexData = codexSnap.val() || {};
        if (Object.keys(codexData).length === 0) {
            listEl.innerHTML = '<p class="text-center col-span-full">Kodekste hiÃ§ avatar bulunmuyor. Eklemek iÃ§in "Yeni Avatar Ekle" butonunu kullanÄ±n.</p>';
            return;
        }

        const sortedAvatars = Object.entries(codexData).sort((a, b) => (a[1].order || 0) - (b[1].order || 0));
        
        listEl.innerHTML = ''; // Temizle

        sortedAvatars.forEach(([sanitizedId, avatarInfo], index) => {
            const avatarHtml = `
                <div class="admin-codex-item relative p-3 bg-gray-800 rounded-lg border border-gray-700 flex items-center gap-4" data-avatar-id="${sanitizedId}">
                    <img src="${avatarInfo.imageUrl}" class="w-16 h-16 rounded-md object-cover flex-shrink-0 self-center">
                    <div class="admin-codex-info flex-grow">
                        <p class="text-lg font-bold text-white">${avatarInfo.name}</p>
                        <p class="text-xs text-gray-400 whitespace-normal">${avatarInfo.obtainMethod || 'AÃ§Ä±klama yok'}</p>
                    </div>
                    <div class="admin-codex-actions flex items-center gap-2 flex-shrink-0">
                        <div class="flex flex-col gap-1">
                            <button onclick="reorderAvatarInCodex('${sanitizedId}', 'up')" ${index === 0 ? 'disabled' : ''} class="p-1 rounded-full bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg class="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"/></svg>
                            </button>
                            <button onclick="reorderAvatarInCodex('${sanitizedId}', 'down')" ${index === sortedAvatars.length - 1 ? 'disabled' : ''} class="p-1 rounded-full bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg class="w-4 h-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
                            </button>
                        </div>
                        <button onclick="openAvatarCreatorModal('${sanitizedId}')" class="p-2 bg-blue-600 hover:bg-blue-500 rounded-lg text-white" title="DÃ¼zenle">âœï¸</button>
                        <button onclick="removeAvatarFromCodex('${sanitizedId}')" class="p-2 bg-red-700 hover:bg-red-600 rounded-lg text-white" title="Kodeksten KaldÄ±r">ğŸ—‘ï¸</button>
                    </div>
                </div>
            `;
            listEl.innerHTML += avatarHtml;
        });
    };
    
    // Dinleyiciyi baÅŸlat ve referansÄ±nÄ± kaydet
    ref.on('value', callback);
    activeListeners.adminCodex = { ref, callback };
}

// MEVCUT closeAdminAvatarCodexModal FONKSÄ°YONUNU SÄ°LÄ°P BUNU YAPIÅTIR
function closeAdminAvatarCodexModal() {
    // Paneli kapatmadan Ã¶nce, aÃ§Ä±k olan dinleyiciyi durdur
    if (activeListeners.adminCodex && activeListeners.adminCodex.ref) {
        activeListeners.adminCodex.ref.off('value', activeListeners.adminCodex.callback);
        delete activeListeners.adminCodex; // ReferansÄ± temizle
    }
    document.getElementById('adminAvatarCodexModal').style.display = 'none';
}
      
/**
 * Avatar ekleme/dÃ¼zenleme formunu aÃ§ar.
 */
async function openAvatarCreatorModal(sanitizedId = null) {
    const modal = document.getElementById('avatarCreatorModal');
    const title = document.getElementById('avatarCreatorTitle');
    editingAvatarData = null; // Ã–nceki dÃ¼zenleme verisini temizle

    // Formu temizle
    document.getElementById('avatarCreatorName').value = '';
    document.getElementById('avatarCreatorImageUrl').value = '';
    document.getElementById('avatarCreatorObtain').value = '';
    document.getElementById('avatarCreatorHp').value = '';
    document.getElementById('avatarCreatorMinDmg').value = '';
    document.getElementById('avatarCreatorMaxDmg').value = '';
    document.getElementById('avatarCreatorCritDmg').value = '';
    document.getElementById('avatarCreatorDefense').value = '';
    document.getElementById('avatarCreatorDodge').value = '';
    document.getElementById('avatarCreatorPierce').value = '';
    document.getElementById('avatarCreatorCrit').value = '';

    if (sanitizedId) {
        // DÃ¼zenleme Modu
        title.textContent = 'AvatarÄ± DÃ¼zenle';
        
        const [codexSnap, statsSnap] = await Promise.all([
            db.ref(`gameConfig/avatarCodex/${sanitizedId}`).once('value'),
            db.ref(`gameConfig/avatarBaseStats/${sanitizedId}`).once('value')
        ]);
        
        const codexData = codexSnap.val();
        const statsData = statsSnap.val();

        if (codexData) {
            editingAvatarData = { id: sanitizedId, order: codexData.order };
            document.getElementById('avatarCreatorName').value = codexData.name || '';
            document.getElementById('avatarCreatorImageUrl').value = codexData.imageUrl || '';
            document.getElementById('avatarCreatorObtain').value = codexData.obtainMethod || '';
        }
        if (statsData) {
            document.getElementById('avatarCreatorHp').value = statsData.hp || '';
            document.getElementById('avatarCreatorMinDmg').value = statsData.minDamage || '';
            document.getElementById('avatarCreatorMaxDmg').value = statsData.maxDamage || '';
            document.getElementById('avatarCreatorCritDmg').value = statsData.critDamage || '';
            document.getElementById('avatarCreatorDefense').value = statsData.defense || '';
            document.getElementById('avatarCreatorDodge').value = statsData.dodgeChance || '';
            document.getElementById('avatarCreatorPierce').value = statsData.pierceChance || '';
            document.getElementById('avatarCreatorCrit').value = statsData.critChance || '';
        }
    } else {
        // Yeni Ekleme Modu
        title.textContent = 'Yeni Avatar Ekle';
    }

    modal.style.display = 'flex';
}

/**
 * Avatar ekleme/dÃ¼zenleme formunu kapatÄ±r.
 */
function closeAvatarCreatorModal() {
    document.getElementById('avatarCreatorModal').style.display = 'none';
    editingAvatarData = null;
}

// MEVCUT saveAvatarData FONKSÄ°YONUNU SÄ°LÄ°P BUNU YAPIÅTIR
async function saveAvatarData() {
    if (!isAdmin) return;

    try {
        const name = document.getElementById('avatarCreatorName').value.trim();
        const imageUrl = document.getElementById('avatarCreatorImageUrl').value.trim();
        const obtainMethod = document.getElementById('avatarCreatorObtain').value.trim();
        
        if (!name || !imageUrl) {
            throw new Error("Avatar AdÄ± ve Resim URL'si zorunludur.");
        }
        
        const stats = {
            hp: parseInt(document.getElementById('avatarCreatorHp').value) || 1000,
            minDamage: parseInt(document.getElementById('avatarCreatorMinDmg').value) || 50,
            maxDamage: parseInt(document.getElementById('avatarCreatorMaxDmg').value) || 100,
            critDamage: parseFloat(String(document.getElementById('avatarCreatorCritDmg').value).replace(',', '.')) || 10.0,
            defense: parseFloat(String(document.getElementById('avatarCreatorDefense').value).replace(',', '.')) || 0.0,
            dodgeChance: parseFloat(String(document.getElementById('avatarCreatorDodge').value).replace(',', '.')) || 5.0,
            pierceChance: parseFloat(String(document.getElementById('avatarCreatorPierce').value).replace(',', '.')) || 5.0,
            critChance: parseFloat(String(document.getElementById('avatarCreatorCrit').value).replace(',', '.')) || 5.0,
        };

        const sanitizedId = sanitizeFirebaseKey(imageUrl);
        const updates = {};
        
        if (editingAvatarData) {
            // DÃ¼zenleme
            updates[`/gameConfig/avatarCodex/${editingAvatarData.id}/name`] = name;
            updates[`/gameConfig/avatarCodex/${editingAvatarData.id}/imageUrl`] = imageUrl;
            updates[`/gameConfig/avatarCodex/${editingAvatarData.id}/obtainMethod`] = obtainMethod;
            updates[`/gameConfig/avatarBaseStats/${editingAvatarData.id}`] = stats;
        } else {
            // Yeni Ekleme
            const codexRef = db.ref('gameConfig/avatarCodex');
            const lastItemSnap = await codexRef.orderByChild('order').limitToLast(1).once('value');
            let nextOrder = 0;
            if (lastItemSnap.exists()) {
                nextOrder = Object.values(lastItemSnap.val())[0].order + 1;
            }

            updates[`/gameConfig/avatarCodex/${sanitizedId}`] = { name, imageUrl, obtainMethod, order: nextOrder };
            updates[`/gameConfig/avatarBaseStats/${sanitizedId}`] = stats;
        }

        await db.ref().update(updates);
        displayMessage(`Avatar '${name}' baÅŸarÄ±yla kaydedildi!`);
        closeAvatarCreatorModal();
        // ARTIK BURADA openAdminAvatarCodexModal() Ã‡AÄIRMIYORUZ! DeÄŸiÅŸiklik anlÄ±k olarak zaten yansÄ±yacak.

    } catch (error) {
        console.error("Avatar kaydedilirken hata:", error);
        displayMessage("Hata: " + error.message);
    }
}

/**
 * AvatarÄ±n Kodeks listesindeki sÄ±rasÄ±nÄ± deÄŸiÅŸtirir.
 */
async function reorderAvatarInCodex(sanitizedId, direction) {
    if (!isAdmin) return;

    const codexRef = db.ref('gameConfig/avatarCodex');
    const codexSnap = await codexRef.orderByChild('order').once('value');
    if (!codexSnap.exists()) return;

    const sortedAvatars = [];
    codexSnap.forEach(snap => {
        sortedAvatars.push({ id: snap.key, ...snap.val() });
    });

    const currentIndex = sortedAvatars.findIndex(avatar => avatar.id === sanitizedId);
    if (currentIndex === -1) return;

    let newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
    if (newIndex < 0 || newIndex >= sortedAvatars.length) return; // SÄ±nÄ±rlarÄ±n dÄ±ÅŸÄ±na Ã§Ä±kmayÄ± engelle

    // ElemanlarÄ± yer deÄŸiÅŸtir
    [sortedAvatars[currentIndex], sortedAvatars[newIndex]] = [sortedAvatars[newIndex], sortedAvatars[currentIndex]];

    // TÃ¼m liste iÃ§in yeni 'order' deÄŸerlerini hazÄ±rla
    const updates = {};
    sortedAvatars.forEach((avatar, index) => {
        updates[`/gameConfig/avatarCodex/${avatar.id}/order`] = index;
    });

    await db.ref().update(updates);
    openAdminAvatarCodexModal(); // Paneli anÄ±nda yenile
}

// =======================================================
// YENÄ° GÃœNCELLENMÄ°Å: PAZARI TEMÄ°ZLEME (ÃœCRET Ä°ADESÄ°Z) FONKSÄ°YONU
// =======================================================

/**
 * Aktif tÃ¼m takas tekliflerini iptal eder, KARTLARI sahiplerine iade eder. Ä°ÅLEM ÃœCRETLERÄ° Ä°ADE EDÄ°LMEZ.
 */
async function clearTradeMarketForSeasonEnd() {
    console.log("Sezon sonu: Takas pazarÄ± temizleniyor (Ã¼cret iadesiz)...");

    const tradesRef = db.ref('trades');
    const usersRef = db.ref('users');

    const [tradesSnap, usersSnap] = await Promise.all([
        tradesRef.once('value'),
        usersRef.once('value')
    ]);

    if (!tradesSnap.exists()) {
        console.log("Pazarda temizlenecek aktif takas teklifi bulunamadÄ±.");
        return;
    }

    const trades = tradesSnap.val();
    const usersData = usersSnap.val();
    const updates = {};

    for (const tradeId in trades) {
        const trade = trades[tradeId];
        const offerer = trade.offerer;
        const offeredCardId = trade.offeredCardId;

        if (usersData && usersData[offerer]) {
            const userPath = `/users/${offerer}`;
            const userData = usersData[offerer];

            // 1. KART Ä°ADESÄ°: Sadece teklife konulan kartÄ±n sayÄ±sÄ±nÄ± 1 artÄ±r.
            const currentCardCount = userData.cardCollection?.[offeredCardId]?.count || 0;
            updates[`${userPath}/cardCollection/${offeredCardId}/count`] = currentCardCount + 1;

            // â˜…â˜…â˜… DEÄÄ°ÅÄ°KLÄ°K BURADA: Ãœcret iadesi yapan kod bloÄŸu tamamen kaldÄ±rÄ±ldÄ±. â˜…â˜…â˜…

            // 2. BÄ°LDÄ°RÄ°M GÃœNCELLEMESÄ°: KullanÄ±cÄ±ya sadece kartÄ±nÄ±n iade edildiÄŸini sÃ¶yle.
            const notifKey = db.ref().push().key;
            updates[`${userPath}/notifications/${notifKey}`] = {
                message: `Kart sezonu bittiÄŸi iÃ§in pazardaki takas teklifin otomatik olarak iptal edildi ve kartÄ±n envanterine iade edildi.`,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };
        }
    }

    // 3. TÃœM TEKLÄ°FLERÄ° SÄ°L
    updates['/trades'] = null;

    if (Object.keys(updates).length > 0) {
        await db.ref().update(updates);
        console.log("Takas pazarÄ± baÅŸarÄ±yla temizlendi, kartlar iade edildi (Ã¼cretler iade edilmedi).");
    }
}

/**
 * YENÄ°: Belirtilen kullanÄ±cÄ±nÄ±n kart koleksiyonunu, joker kartlarÄ±nÄ± ve albÃ¼m tamamlama durumunu sÄ±fÄ±rlar.
 */
async function resetUserCards(username) {
    if (!isAdmin || !username) return;

    const confirmed = await customConfirm(
        `<b>${username}</b> adlÄ± kullanÄ±cÄ±nÄ±n <b>tÃ¼m kart koleksiyonunu, joker kartlarÄ±nÄ± ve albÃ¼m tamamlama durumunu</b> kalÄ±cÄ± olarak sÄ±fÄ±rlamak istediÄŸinize emin misiniz? Bu iÅŸlem geri alÄ±namaz!`
    );

    if (!confirmed) return;

    try {
        const userRef = db.ref(`users/${username}`);
        
        // SÄ±fÄ±rlanacak verileri tek bir iÅŸlemde gÃ¼ncellemek iÃ§in bir obje hazÄ±rlÄ±yoruz.
        const updates = {};
        updates['/cardCollection'] = null;      // TÃ¼m kart koleksiyonunu siler.
        updates['/completedCollection'] = null; // AlbÃ¼m tamamlama durumunu siler.
        updates['/wildcards'] = 0;              // Joker kart sayÄ±sÄ±nÄ± sÄ±fÄ±rlar.

        await userRef.update(updates);
        
        displayMessage(`${username} adlÄ± kullanÄ±cÄ±nÄ±n tÃ¼m kart verileri baÅŸarÄ±yla sÄ±fÄ±rlandÄ±.`);
        
        // ArayÃ¼zÃ¼ anÄ±nda gÃ¼ncellemek iÃ§in yÃ¶netim penceresini yeniden aÃ§
        openUserManagementModal(event, username);
        
    } catch (error) {
        console.error("KullanÄ±cÄ±nÄ±n kartlarÄ± sÄ±fÄ±rlanÄ±rken hata oluÅŸtu:", error);
        displayMessage("Kartlar sÄ±fÄ±rlanÄ±rken bir hata meydana geldi: " + error.message);
    }
}

// YENÄ° FONKSÄ°YON (BUNU EKLE)
/**
 * Avatar Kodeksi ve Temel Ä°statistik verilerini sunucudan Ã§ekip Ã¶nbelleÄŸe alÄ±r.
 */
async function loadCodexAndStatsCache() {
    try {
        const [codexSnap, statsSnap] = await Promise.all([
            db.ref('gameConfig/avatarCodex').once('value'),
            db.ref('gameConfig/avatarBaseStats').once('value')
        ]);
        avatarCodexCache = codexSnap.val() || {};
        avatarBaseStats = statsSnap.val() || {};
        console.log("Avatar Ã¶nbellekleri baÅŸarÄ±yla yÃ¼klendi.");
    } catch (error) {
        console.error("Avatar Ã¶nbellekleri yÃ¼klenirken hata oluÅŸtu:", error);
    }
}

      async function loadAllCardsCache() {
    try {
        const cardsRef = db.ref('gameConfig/cardCollection');
        const snapshot = await cardsRef.once('value');
        allCardsCache = [];
        if (snapshot.exists()) {
            const cardsData = snapshot.val();
            for (const cardId in cardsData) {
                allCardsCache.push({ id: cardId, ...cardsData[cardId] });
            }
            allCardsCache.sort((a, b) => (a.order || 0) - (b.order || 0));
        }
        console.log("TÃ¼m kartlar Ã¶nbelleÄŸe alÄ±ndÄ±:", allCardsCache.length, "adet.");
    } catch (error) {
        console.error("TÃ¼m kartlar Ã¶nbelleÄŸe alÄ±nÄ±rken hata oluÅŸtu:", error);
    }
}

function showQuestion(questionIndex) {
    db.ref(`wordGame/questions/${questionIndex}/isRevealed`).set(true);
}

 // MEVCUT listenForWordGameData FONKSÄ°YONUNU SÄ°LÄ°P BUNU YAPIÅTIRIN
function listenForWordGameData() {
    if (activeWordGameListener) {
        activeWordGameListener.ref.off('value', activeWordGameListener.callback);
    }

    const ref = db.ref('wordGame');
    const callback = (snap) => {
        const gameData = snap.val();
        if (gameData && gameData.questions) {
            renderQuestions(gameData.questions);
            renderWordGameLeaderboard(gameData.leaderboard);
            renderWordGameStatsAndPrize(gameData); // YENÄ° EKLENEN SATIR
        } else {
            document.getElementById('questionsContainer').innerHTML = '<p class="text-center text-gray-400 p-4">Adminin yeni bir bulmaca baÅŸlatmasÄ± bekleniyor.</p>';
            document.getElementById('wordGameLeaderboard').innerHTML = '';
            document.getElementById('wordGameStatsContainer').classList.add('hidden'); // YENÄ° EKLENEN SATIR
        }
    };
    activeWordGameListener = { ref, callback };
    ref.on('value', callback);
    
    if (!isAdmin) {
        const userCooldownRef = db.ref(`users/${currentUser}/wordGameCooldown`);
        userCooldownRef.on('value', snap => handleCooldown(snap.val()));
    }
}

function renderQuestions(questionsData) {
    const container = document.getElementById('questionsContainer');
    container.innerHTML = '';
    const isCoolingDown = wordGameCooldownEnd > getSyncedTime();
    let previousQuestionSolved = true;

    questionsData.forEach((question, qIndex) => {
        // EÄŸer Ã¶nceki soru Ã§Ã¶zÃ¼lmediyse, bu ve sonraki sorularÄ± gÃ¶sterme
        if (!previousQuestionSolved) return;

        const isCurrentQuestionSolved = (question.letters || []).every(letter => letter.solved);

        const questionBlock = document.createElement('div');
        questionBlock.className = 'question-block';
        
        // Soru metnini ve cevap kutularÄ±nÄ± oluÅŸtur
        let contentHtml = `
            <p class="text-lg text-gray-300 mb-4">${qIndex + 1}. Soru: <b class="text-white">${question.text}</b></p>
            <div class="answer-letters-container">
        `;
        
        (question.letters || []).forEach((letter, lIndex) => {
            if (letter.solved) {
                // Ã‡Ã¶zÃ¼lmÃ¼ÅŸ harf kutusu
                contentHtml += `
                    <div class="answer-letter solved" onclick="showSolvedBoxInfo(${qIndex}, ${lIndex})">
                        ${letter.char}
                        
                        <span class="reward-icon" title="${formatRewardText(letter.reward.type, letter.reward.amount || letter.reward.value)}">${getRewardIcon(letter.reward.type)}</span>
                    </div>`;
            } else {
                // â˜…â˜…â˜… DEÄÄ°ÅÄ°KLÄ°K BURADA â˜…â˜…â˜…
                // Ã‡Ã¶zÃ¼lmemiÅŸ harf kutusu (bekleme sÃ¼resindeyse kalan sÃ¼reyi gÃ¶sterir, deÄŸilse harf girme penceresini aÃ§ar)
                const onClickAction = isCoolingDown ? `onclick="showCooldownMessage()"` : `onclick="openLetterInputModal(${qIndex}, ${lIndex})"`;
                contentHtml += `<div class="answer-letter unsolved" ${onClickAction}></div>`;
            }
        });

        contentHtml += `</div>`;
        questionBlock.innerHTML = contentHtml;
        container.appendChild(questionBlock);

        // Bir sonraki dÃ¶ngÃ¼ iÃ§in bu sorunun Ã§Ã¶zÃ¼lÃ¼p Ã§Ã¶zÃ¼lmediÄŸini kaydet
        previousQuestionSolved = isCurrentQuestionSolved;
    });
}

/**
 * YENÄ°: Kelime oyunu bekleme sÃ¼resindeyken kapalÄ± bir kutuya tÄ±klandÄ±ÄŸÄ±nda bilgilendirme mesajÄ± gÃ¶sterir.
 */
function showCooldownMessage() {
    if (wordGameCooldownEnd > getSyncedTime()) {
        const remainingSeconds = Math.ceil((wordGameCooldownEnd - getSyncedTime()) / 1000);
        const durationText = formatDurationFromSeconds(remainingSeconds);
        displayMessage(`Tekrar harf girebilmek iÃ§in beklemen gerekiyor. Kalan sÃ¼re: <b class="text-yellow-300">${durationText}</b>`);
    }
}
   
function renderWordGameLeaderboard(leaderboardData) {
    const leaderboardEl = document.getElementById('wordGameLeaderboard');
    if (!leaderboardData) {
        leaderboardEl.innerHTML = '<p class="text-center text-gray-500">HenÃ¼z kimse harf Ã§Ã¶zmedi.</p>';
        return;
    }

    const sorted = Object.entries(leaderboardData).sort((a, b) => b[1].score - a[1].score);
    
    let html = '';
    sorted.forEach(([username, data], index) => {
        const avatarUrl = data.avatarUrl || defaultAvatarUrl;
        html += `
            <div class="flex items-center p-2 bg-gray-800 rounded-md">
                <span class="font-bold text-lg text-gray-400 w-8 text-center">${index + 1}.</span>
                <img src="${avatarUrl}" class="w-10 h-10 rounded-full object-cover ml-2 mr-4 cursor-pointer" onclick="openPublicUserDetailModal('${username}')">
                <div class="flex-grow">
                    <p class="font-bold text-white cursor-pointer hover:underline" onclick="openPublicUserDetailModal('${username}')">${username}</p>
                    <p class="text-sm text-yellow-300">${data.score} Harf</p>
                </div>
            </div>
        `;
    });
    leaderboardEl.innerHTML = html;
}

function openLetterInputModal(qIndex, lIndex) {
    // â˜…â˜…â˜… DEÄÄ°ÅÄ°KLÄ°K BURADA â˜…â˜…â˜…
    // Bekleme sÃ¼resi bitmeden bu pencerenin aÃ§Ä±lmasÄ±nÄ± engelleyen ek kontrol.
    if (wordGameCooldownEnd > getSyncedTime()) {
        showCooldownMessage(); // Kalan sÃ¼reyi gÃ¶ster
        return;
    }

    const modal = document.getElementById('letterInputModal');
    const input = document.getElementById('letterInput');
    modal.dataset.qIndex = qIndex;
    modal.dataset.lIndex = lIndex;
    input.value = '';
    modal.style.display = 'flex';
    input.focus();
}

function closeLetterInputModal() {
    document.getElementById('letterInputModal').style.display = 'none';
}

async function submitLetter() {
    if (isAdmin) {
        displayMessage("Adminler oyun oynayamaz.");
        closeLetterInputModal();
        return;
    }

    const modal = document.getElementById('letterInputModal');
    const input = document.getElementById('letterInput');
    const letter = input.value.trim().toLocaleUpperCase('tr-TR');
    const qIndex = parseInt(modal.dataset.qIndex);
    const lIndex = parseInt(modal.dataset.lIndex);

    if (letter.length !== 1 || !/^[A-ZÃ‡ÄÄ°Ã–ÅÃœ]$/.test(letter)) {
        displayMessage("LÃ¼tfen geÃ§erli tek bir harf girin.");
        return;
    }

    closeLetterInputModal();

    const cellRef = db.ref(`wordGame/questions/${qIndex}/letters/${lIndex}`);
    const userRef = db.ref(`users/${currentUser}`);
    
    // Bekleme sÃ¼resi panelini ve iÃ§eriÄŸini en baÅŸtan alalÄ±m
    const cooldownInfoEl = document.getElementById('wordGameCooldownInfo');
    const cooldownTextEl = cooldownInfoEl.childNodes[0]; // "YanlÄ±ÅŸ harf girdin..." metni

    try {
        const { committed, snapshot } = await cellRef.transaction(letterData => {
            if (letterData && !letterData.solved) {
                if (letterData.char === letter) {
                    letterData.solved = true;
                    letterData.solver = currentUser;
                    letterData.solvedAt = firebase.database.ServerValue.TIMESTAMP;
                }
                return letterData;
            }
            return; 
        });

        if (committed) {
            const finalLetterData = snapshot.val();
            if (finalLetterData.solved && finalLetterData.solver === currentUser) {
                // --- DOÄRU CEVAP VERÄ°LDÄ° ---
                
                // 1. Panelin rengini ve yazÄ±sÄ±nÄ± DEÄÄ°ÅTÄ°R
                cooldownTextEl.textContent = 'Tekrar harf yazmak iÃ§in beklemen gereken sÃ¼re: ';
                cooldownInfoEl.className = 'text-center bg-blue-900/50 border border-blue-500 text-blue-300 p-3 rounded-lg mb-4';

                const reward = finalLetterData.reward;
                const rewardText = formatRewardText(reward.type, reward.amount || reward.value, reward.uses);
                
                const correctCooldownSeconds = (await db.ref('wordGame/settings/correctGuessCooldown').once('value')).val() || 60;
                await userRef.update({
                    wordGameCooldown: getSyncedTime() + (correctCooldownSeconds * 1000)
                });
                const durationText = formatDurationFromSeconds(correctCooldownSeconds);
                displayMessage(`Harf doÄŸru! KazandÄ±ÄŸÄ±n Ã¶dÃ¼l: <b class="text-green-400">${rewardText}</b><br><small class="text-yellow-300">${durationText} bekleme sÃ¼ren baÅŸladÄ±.</small>`);
                
                let cardPacksToOpen = [];
                let newBalance; 

                await userRef.transaction(userData => {
                    if (userData) {
                        const result = applyRewardToUser(userData, reward);
                        cardPacksToOpen.push(...result.cardPacksToOpen);
                        newBalance = userData.balance; 
                    }
                    return userData;
                });
                
                const leaderboardRef = db.ref(`wordGame/leaderboard/${currentUser}`);
                const userAvatar = (await userRef.child('selectedAvatar/url').once('value')).val() || defaultAvatarUrl;
                await leaderboardRef.transaction(currentData => ({
                    score: (currentData?.score || 0) + 1,
                    avatarUrl: userAvatar
                }));

                const logDetails = { letter: letter, rewardText: rewardText };
                if (reward.type === 'points') logDetails.newBalance = newBalance; 
                logActivity('wordGameGuess', currentUser, logDetails);
                
                for (const pack of cardPacksToOpen) {
                    await startCardPackOpening(pack.value || 1, 'Kelime Oyunu', 1, pack.type);
                }
                
                if (!isAdmin) {
                    checkForGameCompletionAndAwardChampion();
                }

            } else {
                // --- YANLIÅ CEVAP VERÄ°LDÄ° ---
                
                // 1. Panelin rengini ve yazÄ±sÄ±nÄ± ORÄ°JÄ°NAL HALÄ°NE GETÄ°R
                cooldownTextEl.textContent = 'YanlÄ±ÅŸ harf girdin! Tekrar denemek iÃ§in beklemen gereken sÃ¼re: ';
                cooldownInfoEl.className = 'text-center bg-red-900/50 border border-red-500 text-red-300 p-3 rounded-lg mb-4';
                
                const cooldownSeconds = (await db.ref('wordGame/settings/cooldown').once('value')).val() || 60;
                await userRef.update({
                    wordGameCooldown: getSyncedTime() + (cooldownSeconds * 1000)
                });
                const durationText = formatDurationFromSeconds(cooldownSeconds);
                displayMessage(`Harf yanlÄ±ÅŸ! ${durationText} sonra tekrar deneyebilirsin.`);

                logActivity('wordGameWrongGuess', currentUser, {
                    letter: letter,
                    cooldown: cooldownSeconds
                });
            }
        } else {
            const competitorData = (await cellRef.once('value')).val();
            if (competitorData && competitorData.solver) {
                displayMessage(`Bu kutuyu senden hemen Ã¶nce <b class="text-yellow-300">${competitorData.solver}</b> Ã§Ã¶zdÃ¼!`);
            }
        }
    } catch (error) {
        console.error("Harf gÃ¶nderme hatasÄ±:", error);
        displayMessage("Bir hata oluÅŸtu.");
    }
}

function handleCooldown(cooldownEndTimestamp) {
    if (wordGameCooldownInterval) clearInterval(wordGameCooldownInterval);
    const infoEl = document.getElementById('wordGameCooldownInfo');
    const timerEl = document.getElementById('wordGameCooldownTimer');
    
    // â–¼â–¼â–¼ YENÄ° EKLENEN KISIM BAÅLANGICI â–¼â–¼â–¼
    // EÄŸer kullanÄ±cÄ± admin ise, zamanlayÄ±cÄ±yÄ± kesinlikle gÃ¶sterme ve durdur.
    if (isAdmin) {
        infoEl.classList.add('hidden');
        wordGameCooldownEnd = 0;
        return;
    }
    // â–²â–²â–² YENÄ° EKLENEN KISIM SONU â–²â–²â–²
    
    wordGameCooldownEnd = cooldownEndTimestamp || 0;

    const updateTimer = () => {
        const now = getSyncedTime();
        if (now >= wordGameCooldownEnd) {
            infoEl.classList.add('hidden');
            clearInterval(wordGameCooldownInterval);
            listenForWordGameData(); 
        } else {
            const remainingSeconds = Math.ceil((wordGameCooldownEnd - now) / 1000);
            timerEl.textContent = formatDurationFromSeconds(remainingSeconds);
            infoEl.classList.remove('hidden');
        }
    };
    
    if (wordGameCooldownEnd > getSyncedTime()) {
        updateTimer();
        wordGameCooldownInterval = setInterval(updateTimer, 1000);
    } else {
        infoEl.classList.add('hidden');
    }
}

// MEVCUT showSolvedBoxInfo FONKSÄ°YONUNU SÄ°L VE BUNUNLA DEÄÄ°ÅTÄ°R

async function showSolvedBoxInfo(qIndex, lIndex) {
    const letterSnap = await db.ref(`wordGame/questions/${qIndex}/letters/${lIndex}`).once('value');
    const letterData = letterSnap.val();
    if (!letterData) return;

    const contentEl = document.getElementById('solvedBoxInfoContent');
    
    // â˜…â˜…â˜… DEÄÄ°ÅEN SATIR BAÅLANGICI â˜…â˜…â˜…
    // ArtÄ±k formatRewardText fonksiyonuna 3. parametre olarak "letterData.reward.uses" deÄŸerini de gÃ¶nderiyoruz.
    const rewardText = formatRewardText(letterData.reward.type, letterData.reward.amount || letterData.reward.value, letterData.reward.uses);
    // â˜…â˜…â˜… DEÄÄ°ÅEN SATIR SONU â˜…â˜…â˜…

    contentEl.innerHTML = `
        <p>Ã‡Ã¶zen: <b class="text-white cursor-pointer hover:underline" onclick="openPublicUserDetailModal('${letterData.solver}')">${letterData.solver}</b></p>
        <p>Harf: <b class="text-white">${letterData.char}</b></p>
        <p>KazanÄ±lan Ã–dÃ¼l: <b class="text-green-400">${rewardText}</b></p>
        <p class="text-xs text-gray-400 mt-2">${new Date(letterData.solvedAt).toLocaleString('tr-TR')}</p>
    `;
    document.getElementById('solvedBoxInfoModal').style.display = 'flex';
}

function closeSolvedBoxInfoModal() {
    document.getElementById('solvedBoxInfoModal').style.display = 'none';
}

function closeWordGameAdminModal() {
    document.getElementById('wordGameAdminModal').style.display = 'none';
}

function addQuestionBlock() {
    const container = document.getElementById('questionBlocksContainer');
    const block = document.createElement('div');
    block.className = 'p-3 bg-gray-900/50 rounded-lg border border-gray-700';
    block.innerHTML = `
        <div class="flex justify-between items-center mb-2">
            <label class="text-gray-300">Soru & Cevap</label>
            <button onclick="this.parentElement.parentElement.remove()" class="py-1 px-2 bg-red-600 hover:bg-red-500 rounded-md text-xs">Bu Soruyu Sil</button>
        </div>
        <textarea class="box-setting-input question-text mb-2" rows="2" placeholder="Soru metnini buraya yazÄ±n..."></textarea>
        <input type="text" class="box-setting-input answer-text uppercase" placeholder="CEVAP" oninput="generateRewardFields(this)">
        <div class="letter-rewards-container mt-2 space-y-2"></div>
    `;
    container.appendChild(block);
}

   // MEVCUT openWordGameAdminModal FONKSÄ°YONUNU SÄ°LÄ°P BUNU YAPIÅTIR
async function openWordGameAdminModal() {
    if (!isAdmin) return;
    const container = document.getElementById('questionBlocksContainer');
    container.innerHTML = '<p class="text-center text-gray-400">Mevcut oyun ayarlarÄ± yÃ¼kleniyor...</p>';
    document.getElementById('wordGameAdminModal').style.display = 'flex';

    const gameSnap = await db.ref('wordGame').once('value');
    const gameData = gameSnap.val();

    container.innerHTML = ''; // Paneli temizle

    // YanlÄ±ÅŸ cevap bekleme sÃ¼resini yÃ¼kle
    const cooldownSecondsTotal = (gameData && gameData.settings) ? gameData.settings.cooldown || 60 : 60;
    const days = Math.floor(cooldownSecondsTotal / 86400);
    let remainder = cooldownSecondsTotal % 86400;
    const hours = Math.floor(remainder / 3600);
    remainder %= 3600;
    const minutes = Math.floor(remainder / 60);
    const seconds = remainder % 60;
    document.getElementById('cooldownDays').value = days > 0 ? days : '';
    document.getElementById('cooldownHours').value = hours > 0 ? hours : '';
    document.getElementById('cooldownMinutes').value = minutes > 0 ? minutes : '';
    document.getElementById('cooldownSeconds').value = seconds > 0 ? seconds : '';

    // YENÄ° EKLENEN KISIM: DoÄŸru cevap bekleme sÃ¼resini yÃ¼kle
    const correctCooldownSecondsTotal = (gameData && gameData.settings) ? gameData.settings.correctGuessCooldown || 60 : 60;
    const cDays = Math.floor(correctCooldownSecondsTotal / 86400);
    let cRemainder = correctCooldownSecondsTotal % 86400;
    const cHours = Math.floor(cRemainder / 3600);
    cRemainder %= 3600;
    const cMinutes = Math.floor(cRemainder / 60);
    const cSeconds = cRemainder % 60;
    document.getElementById('correctCooldownDays').value = cDays > 0 ? cDays : '';
    document.getElementById('correctCooldownHours').value = cHours > 0 ? cHours : '';
    document.getElementById('correctCooldownMinutes').value = cMinutes > 0 ? cMinutes : '';
    document.getElementById('correctCooldownSeconds').value = cSeconds > 0 ? cSeconds : '';
    // YENÄ° KISIM SONU

    if (gameData && gameData.questions && gameData.questions.length > 0) {
        gameData.questions.forEach(questionData => {
            addQuestionBlock(questionData);
        });
    } else {
        addQuestionBlock();
    }
    
    loadWordGameChampionPrize();
}

function addQuestionBlock(questionData = null) {
    const container = document.getElementById('questionBlocksContainer');
    const block = document.createElement('div');
    block.className = 'p-3 bg-gray-900/50 rounded-lg border border-gray-700';
    
    // Veri varsa input'larÄ± doldur, yoksa boÅŸ bÄ±rak
    const questionText = questionData ? questionData.text : '';
    const answerText = questionData ? questionData.answer : '';

    block.innerHTML = `
        <div class="flex justify-between items-center mb-2">
            <label class="text-gray-300">Soru & Cevap</label>
            <button onclick="this.parentElement.parentElement.remove()" class="py-1 px-2 bg-red-600 hover:bg-red-500 rounded-md text-xs">Bu Soruyu Sil</button>
        </div>
        <textarea class="box-setting-input question-text mb-2" rows="2" placeholder="Soru metnini buraya yazÄ±n...">${questionText}</textarea>
        <input type="text" class="box-setting-input answer-text uppercase" placeholder="CEVAP" value="${answerText}" oninput="generateRewardFields(this)">
        <div class="letter-rewards-container mt-2 space-y-2"></div>
    `;
    container.appendChild(block);

    // EÄŸer veri varsa, Ã¶dÃ¼l alanlarÄ±nÄ± da bu veriye gÃ¶re oluÅŸtur
    if (questionData) {
        generateRewardFields(block.querySelector('.answer-text'), questionData.letters);
    }
}

function generateRewardFields(answerInput, lettersData = null) {
    const answer = answerInput.value.trim().toLocaleUpperCase('tr-TR').replace(/[^A-ZÃ‡ÄÄ°Ã–ÅÃœ]/g, '');
    answerInput.value = answer; 
    const container = answerInput.parentElement.querySelector('.letter-rewards-container');
    container.innerHTML = '';

    for (let i = 0; i < answer.length; i++) {
        const letter = answer[i];
        const rewardData = lettersData ? lettersData[i]?.reward : {};
        
        // Ã–nce her satÄ±r iÃ§in bir ana taÅŸÄ±yÄ±cÄ± element oluÅŸturuyoruz
        const wrapperDiv = document.createElement('div');
        wrapperDiv.className = 'flex items-center gap-2';

        // SatÄ±rÄ±n iÃ§eriÄŸini HTML olarak bu elemente ekliyoruz
        wrapperDiv.innerHTML = `
            <span class="font-bold text-yellow-300 w-8 text-center text-lg">${letter}</span>
            ${getRewardItemHTML(`reward_${i}`, rewardData)}
        `;
        
        // TamamlanmÄ±ÅŸ satÄ±rÄ± ana konteynere ekliyoruz
        container.appendChild(wrapperDiv);

        // Åimdi, YALNIZCA YENÄ° EKLEDÄ°ÄÄ°MÄ°Z SATIRIN iÃ§indeki elementleri bularak
        // doÄŸru input'larÄ±n gÃ¶rÃ¼nmesini saÄŸlayan fonksiyonu Ã§aÄŸÄ±rÄ±yoruz.
        const newRow = wrapperDiv.querySelector('.reward-entry');
        if (newRow) {
            handleAdminRewardTypeChange(newRow.querySelector('.reward-type'), rewardData);
        }
    }
}

// MEVCUT saveWordGameSettings FONKSÄ°YONUNU SÄ°LÄ°P BUNU YAPIÅTIR
async function saveWordGameSettings(shouldResetProgress = false) {
    if (!isAdmin) return;
    
    let confirmationMessage = '';
    if (shouldResetProgress) {
        confirmationMessage = "Bu iÅŸlem mevcut bulmacayÄ± tamamen silip yenisini oluÅŸturacak ve liderlik tablosunu sÄ±fÄ±rlayacaktÄ±r. Emin misiniz?";
    } else {
        confirmationMessage = "Mevcut kelime oyunu ayarlarÄ±nÄ± bu ÅŸekilde gÃ¼ncellemek istediÄŸinize emin misiniz? <br><br><small class='text-yellow-300'>Bu iÅŸlem oyuncularÄ±n mevcut serilerini SIFIRLAMAZ, sadece Ã¶dÃ¼lleri gÃ¼nceller.</small>";
    }
    // saveWordGameSettings fonksiyonundaki if (shouldResetProgress) bloÄŸunun iÃ§ine ekle
logActivity('event', 'WeizendTv', { eventType: 'wordgame', status: 'started' }, 'etkinlikler');
    
    const confirmed = await customConfirm(confirmationMessage);
    if (!confirmed) return;

    try {
        const oldGameSnap = await db.ref('wordGame').once('value');
        const oldGameData = oldGameSnap.val();

        const questions = [];
        const questionBlocks = document.querySelectorAll('#questionBlocksContainer > div');
        let hasError = false;

        for (const [qIndex, block] of questionBlocks.entries()) {
            if (hasError) continue;
            const questionText = block.querySelector('.question-text').value.trim();
            const answer = block.querySelector('.answer-text').value.trim().toLocaleUpperCase('tr-TR');
            
            if (!questionText || !answer) continue;

            const letters = [];
            const rewardRows = block.querySelectorAll('.letter-rewards-container .reward-entry');
            if (rewardRows.length !== answer.length) {
                hasError = true;
                throw new Error(`'${questionText}' sorusunun cevabÄ±ndaki harf sayÄ±sÄ± ile Ã¶dÃ¼l sayÄ±sÄ± eÅŸleÅŸmiyor!`);
            }

            for (let i = 0; i < answer.length; i++) {
                const char = answer[i];
                const reward = parseRewardDataFromRow(rewardRows[i]);
                if (!reward) {
                    hasError = true;
                    throw new Error(`'${questionText}' sorusundaki '${char}' harfinin Ã¶dÃ¼lÃ¼ geÃ§ersiz.`);
                }
                
                let letterState = {
                    char: char,
                    reward: reward,
                    solved: false,
                    solver: null,
                    solvedAt: null
                };

                if (!shouldResetProgress && oldGameData && oldGameData.questions && oldGameData.questions[qIndex]) {
                    const oldQuestion = oldGameData.questions[qIndex];
                    if (oldQuestion.answer === answer && oldQuestion.letters[i] && oldQuestion.letters[i].solved) {
                        letterState.solved = true;
                        letterState.solver = oldQuestion.letters[i].solver;
                        letterState.solvedAt = oldQuestion.letters[i].solvedAt;
                    }
                }
                letters.push(letterState);
            }
            questions.push({ text: questionText, answer: answer, letters: letters });
        }
        
        if (hasError) return;

        // YanlÄ±ÅŸ cevap bekleme sÃ¼resini al
        const days = parseInt(document.getElementById('cooldownDays').value) || 0;
        const hours = parseInt(document.getElementById('cooldownHours').value) || 0;
        const minutes = parseInt(document.getElementById('cooldownMinutes').value) || 0;
        const seconds = parseInt(document.getElementById('cooldownSeconds').value) || 0;
        const totalCooldownSeconds = (days * 86400) + (hours * 3600) + (minutes * 60) + seconds;

        // YENÄ° EKLENEN KISIM: DoÄŸru cevap bekleme sÃ¼resini al
        const cDays = parseInt(document.getElementById('correctCooldownDays').value) || 0;
        const cHours = parseInt(document.getElementById('correctCooldownHours').value) || 0;
        const cMinutes = parseInt(document.getElementById('correctCooldownMinutes').value) || 0;
        const cSeconds = parseInt(document.getElementById('correctCooldownSeconds').value) || 0;
        const totalCorrectCooldownSeconds = (cDays * 86400) + (cHours * 3600) + (cMinutes * 60) + cSeconds;
        // YENÄ° KISIM SONU

        const updates = {};
        updates['/wordGame/settings'] = {
            cooldown: totalCooldownSeconds,
            correctGuessCooldown: totalCorrectCooldownSeconds // Yeni ayarÄ± kaydet
        };
        updates['/wordGame/questions'] = questions;

        if (shouldResetProgress) {
            updates['/wordGame/leaderboard'] = null; 
            updates['/gameStats/wordGameChampion'] = null; // Åampiyonu da sÄ±fÄ±rla
            
            const usersSnap = await db.ref('users').once('value');
            if (usersSnap.exists()) {
                usersSnap.forEach(user => {
                    if (user.val().wordGameCooldown) {
                        updates[`/users/${user.key}/wordGameCooldown`] = null;
                    }
                });
            }

            displayMessage("Kelime Oyunu baÅŸarÄ±yla sÄ±fÄ±rlandÄ± ve yeni ayarlarla baÅŸlatÄ±ldÄ±!");
        } else {
            displayMessage("Kelime Oyunu ayarlarÄ± baÅŸarÄ±yla gÃ¼ncellendi. OyuncularÄ±n ilerlemesi korundu.");
        }

        await db.ref().update(updates);
        closeWordGameAdminModal();

    } catch (error) {
        displayMessage(`Hata: ${error.message}`);
    }
}

async function resetWordGame() {
    if (!isAdmin) return;
    const confirmed = await customConfirm("TÃ¼m bulmacayÄ± ve liderlik tablosunu sÄ±fÄ±rlamak istediÄŸinize emin misiniz?");
    if (confirmed) {
        await db.ref('wordGame').remove();
        displayMessage("Kelime oyunu baÅŸarÄ±yla sÄ±fÄ±rlandÄ±.");
        closeWordGameAdminModal();
    }
}

function getRewardIcon(type) {
    // â˜…â˜…â˜… DEÄÄ°ÅÄ°KLÄ°K BURADA: Eksik olan tÃ¼m ikonlar eklendi â˜…â˜…â˜…
    const iconMap = {
        points: 'ğŸ’°',
        boxRights: 'ğŸ“¦',
        wheelTicket: 'ğŸ«',
        clickCatchTicket: 'ğŸŸï¸',
        iflasShield: 'ğŸ›¡ï¸',
        tempMultiplier: 'âœ–ï¸',
        wildcard: 'ğŸƒ',
        card_pack: 'ğŸ´',
        card_pack_normal: 'ğŸ¥‰',
        card_pack_gumus: 'ğŸ¥ˆ',
        card_pack_altin: 'ğŸ¥‡',
        card_pack_efsanevi: 'ğŸ†',
        revival_stone: 'ğŸ’',
        health_potion: 'ğŸ§ª',
        damage_potion: 'âš”ï¸',
        defense_potion: 'ğŸ›¡ï¸',
        crit_potion: 'ğŸ’¥',
        crit_damage_potion: 'ğŸ¯',
        dodge_potion: 'ğŸ’¨',
        pierce_potion: 'ğŸ“Œ',
        health_regen_potion: 'ğŸ§ª'
    };
    return iconMap[type] || 'ğŸ'; // EÅŸleÅŸme bulunamazsa varsayÄ±lan olarak hediye paketi gÃ¶ster
}

/**
 * Saniyeyi "X gÃ¼n Y saat Z dakika W saniye" formatÄ±na Ã§evirir.
 * SÄ±fÄ±r olan birimleri atlar (Ã¶rn: 0 gÃ¼n demez).
 * @param {number} totalSeconds - Ã‡evrilecek toplam saniye.
 * @returns {string} BiÃ§imlendirilmiÅŸ zaman metni.
 */
function formatDurationFromSeconds(totalSeconds) {
    if (totalSeconds <= 0) {
        return "0 saniye";
    }

    const days = Math.floor(totalSeconds / 86400);
    totalSeconds %= 86400;
    const hours = Math.floor(totalSeconds / 3600);
    totalSeconds %= 3600;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60); // Math.floor ekledik

    const parts = [];
    if (days > 0) parts.push(`${days} gÃ¼n`);
    if (hours > 0) parts.push(`${hours} saat`);
    if (minutes > 0) parts.push(`${minutes} dakika`);
    if (seconds > 0) parts.push(`${seconds} saniye`);

    // EÄŸer hiÃ§bir parÃ§a yoksa (Ã§ok kÃ¼Ã§Ã¼k bir saniye deÄŸeri iÃ§in), 0 saniye dÃ¶ndÃ¼r
    return parts.length > 0 ? parts.join(' ') : "0 saniye";
}

// YENÄ° EKLENECEK FONKSÄ°YONLAR BAÅLANGICI

/**
 * Kelime Oyunu ÅŸampiyonunu ve Ã¶dÃ¼lÃ¼nÃ¼ Firebase'den dinler ve paneli gÃ¼nceller.
 */
function listenForWordGameChampion() {
    const ref = db.ref('gameStats/wordGameChampion');
    const panel = document.getElementById('wordGameChampionPanel');

    const callback = snap => {
        const data = snap.val();
        if (!data || !data.username) {
            panel.classList.add('hidden');
            return;
        }

        const adminDeleteButton = isAdmin ? `
            <button onclick="db.ref('gameStats/wordGameChampion').remove()" class="absolute -top-3 -right-3 bg-red-600 hover:bg-red-500 text-white rounded-full h-8 w-8 flex items-center justify-center text-lg font-bold" title="Åampiyon Panelini Gizle">&times;</button>
        ` : '';

        const championHtml = `
            ${adminDeleteButton}
            <h4 class="text-green-300 text-xl font-bold mb-3">ğŸ¯ Kelime AvcÄ±sÄ± Åampiyonu ğŸ¯</h4>
            <div class="flex items-center justify-center gap-4">
                <img src="${data.avatarUrl}" class="w-16 h-16 rounded-full border-2 border-yellow-300 object-cover cursor-pointer" onclick="openAvatarStatsModal('${data.username}')">
                <div>
                    <p class="text-xl font-bold text-white cursor-pointer hover:underline" onclick="openPublicUserDetailModal('${data.username}')">${data.username}</p>
                    <p class="text-gray-300">Toplam Ã‡Ã¶zÃ¼len: <b class="text-yellow-400">${data.score} Harf</b></p>
                    <p class="text-gray-300">Ã–dÃ¼l: <b class="text-green-400">${data.prizeAwarded}</b></p>
                </div>
            </div>
        `;

        panel.innerHTML = championHtml;
        panel.classList.remove('hidden');
    };
    
    if (activeListeners.wordGameChampion) {
        activeListeners.wordGameChampion.ref.off('value', activeListeners.wordGameChampion.callback);
    }
    activeListeners.wordGameChampion = { ref, event: 'value', callback };
    ref.on('value', callback);
}

/**
 * Admin: Kelime oyunu ÅŸampiyonu iÃ§in Ã¶dÃ¼l ayarlarÄ±nÄ± kaydeder.
 */
async function saveWordGameChampionPrize() {
    if (!isAdmin) return;
    const container = document.getElementById('wordGameChampionPrizeContainer');
    const reward = parseRewardDataFromRow(container.querySelector('.reward-entry'));
    if (reward) {
        await db.ref('wordGame/settings/championPrize').set(reward);
        displayMessage("Kelime Oyunu ÅŸampiyon Ã¶dÃ¼lÃ¼ baÅŸarÄ±yla kaydedildi.");
    } else {
        displayMessage("Hata: GeÃ§ersiz Ã¶dÃ¼l bilgileri girildi.");
    }
}

/**
 * Admin: KayÄ±tlÄ± ÅŸampiyon Ã¶dÃ¼lÃ¼nÃ¼ yÃ¼kler ve paneli oluÅŸturur.
 */
async function loadWordGameChampionPrize() {
    const container = document.getElementById('wordGameChampionPrizeContainer');
    const prizeSnap = await db.ref('wordGame/settings/championPrize').once('value');
    const prizeData = prizeSnap.val() || {};
    
    container.innerHTML = getRewardItemHTML('champion_prize', prizeData);
    const selectElement = container.querySelector('.reward-type');
    if (selectElement) {
        handleAdminRewardTypeChange(selectElement, prizeData);
    }
    // Kaydet butonu
    container.innerHTML += `<button onclick="saveWordGameChampionPrize()" class="w-full mt-2 py-2 bg-blue-700 hover:bg-blue-600 text-white font-bold rounded-lg md:col-span-3">Åampiyon Ã–dÃ¼lÃ¼nÃ¼ Kaydet</button>`;
}

/**
 * TÃ¼m harfler Ã§Ã¶zÃ¼ldÃ¼ÄŸÃ¼nde ÅŸampiyonu belirler ve Ã¶dÃ¼lÃ¼nÃ¼ verir.
 */
async function checkForGameCompletionAndAwardChampion() {
    // Ã–nce ÅŸampiyonun zaten belirlenip belirlenmediÄŸini kontrol et
    const existingChampionSnap = await db.ref('gameStats/wordGameChampion').once('value');
    if (existingChampionSnap.exists()) {
        console.log("Oyun ÅŸampiyonu zaten belirlenmiÅŸ, iÅŸlem atlandÄ±.");
        return;
    }
    
    const gameSnap = await db.ref('wordGame').once('value');
    const gameData = gameSnap.val();
    
    if (!gameData || !gameData.questions) return;

    const allSolved = gameData.questions.every(q => q.letters.every(l => l.solved));

    if (allSolved) {
        console.log("TÃ¼m harfler Ã§Ã¶zÃ¼ldÃ¼! Åampiyon belirleniyor...");
        const leaderboard = gameData.leaderboard;
        if (!leaderboard) return;

        const sorted = Object.entries(leaderboard).sort((a, b) => b[1].score - a[1].score);
        if (sorted.length === 0) return;

        const winnerUsername = sorted[0][0];
        const winnerData = sorted[0][1];
        
        const prizeData = gameData.settings?.championPrize;
        if (!prizeData) {
            console.log("Åampiyon Ã¶dÃ¼lÃ¼ ayarlanmamÄ±ÅŸ, Ã¶dÃ¼l verilemedi.");
            return;
        }

        const prizeText = formatRewardText(prizeData.type, prizeData.amount || prizeData.value, prizeData.uses);

        // Åampiyon bilgilerini kaydet
        await db.ref('gameStats/wordGameChampion').set({
            username: winnerUsername,
            score: winnerData.score,
            prizeAwarded: prizeText,
            avatarUrl: winnerData.avatarUrl,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });

        // Ã–dÃ¼lÃ¼ kullanÄ±cÄ±ya ver
        const userRef = db.ref(`users/${winnerUsername}`);
        await userRef.transaction(userData => {
            if (userData) {
                applyRewardToUser(userData, prizeData);
            }
            return userData;
        });

        // Aktivite kaydÄ±
        logActivity('wordGameChampion', winnerUsername, { score: winnerData.score, prize: prizeText });
        // checkForGameCompletionAndAwardChampion fonksiyonundaki logActivity('wordGameChampion'...) satÄ±rÄ±nÄ±n altÄ±na ekle
logActivity('event', 'WeizendTv', { eventType: 'wordgame', status: 'finished', winner: winnerUsername }, 'etkinlikler');

    }
}

   // --- YENÄ° EKLENECEK BÄ°LGÄ° PENCERESÄ° FONKSÄ°YONLARI ---

function openCraftingInfoModal() {
    document.getElementById('craftingInfoModal').style.display = 'flex';
}
function closeCraftingInfoModal() {
    document.getElementById('craftingInfoModal').style.display = 'none';
}
function openWordGameInfoModal() {
    document.getElementById('wordGameInfoModal').style.display = 'flex';
}
function closeWordGameInfoModal() {
    document.getElementById('wordGameInfoModal').style.display = 'none';
}

   // YENÄ° EKLENECEK FONKSÄ°YON: Kelime oyunu istatistiklerini ve Ã¶dÃ¼lÃ¼nÃ¼ ekrana yazar.
function renderWordGameStatsAndPrize(gameData) {
    const container = document.getElementById('wordGameStatsContainer');
    if (!gameData || !gameData.questions || gameData.questions.length === 0) {
        container.classList.add('hidden');
        return;
    }

    const questions = gameData.questions;
    const totalQuestions = questions.length;
    const solvedQuestions = questions.filter(q => (q.letters || []).every(l => l.solved)).length;
    const remainingQuestions = totalQuestions - solvedQuestions;

    document.getElementById('totalQuestionsStat').textContent = totalQuestions;
    document.getElementById('solvedQuestionsStat').textContent = solvedQuestions;
    document.getElementById('remainingQuestionsStat').textContent = remainingQuestions;

    const prize = gameData.settings?.championPrize;
    const prizeEl = document.getElementById('wordGameChampionPrize');
    if (prize) {
        prizeEl.textContent = formatRewardText(prize.type, prize.amount || prize.value, prize.uses);
    } else {
        prizeEl.textContent = 'HenÃ¼z belirlenmedi';
    }

    container.classList.remove('hidden');
}
   
// YENÄ° EKLENECEK FONKSÄ°YONLAR SONU
</script>
</body>
</html>
